# 3. UART

## 3.1. uart-SDK应用

### 3.1.1. uart串口打印调试

uart串口打印调试使用uart0，以下在板级文件中配置串口打印的IO口和波特率

uart打印IO口，可配置为芯片任意IO口

![img14](/pic/14.png)

以下为串口打印开库打印总开关和打印系统时间和异常断言信息

![img15](/pic/15.png)

![img16](/pic/16.png)



### 3.1.2. 串口在线调音

![img19](/pic/19.png)

本截图以696x-170SDK-新音箱配置工具&调音工具为案例，串口在线调音的具体方法可参考下文EQ调试小节。



## 3.2. uart应用

### 3.2.1. 串口通信demo

串口通信demo在uart_test.c中，使能该文件，在uart_dev_test_main中设置好脚位，波特率等参数，并在开机硬件初始化完成后调用该函数，实现串口收发

![img17](/pic/17.png)

![img18](/pic/18.png)



### 3.2.2. AC696X 串口单io收发数据

注意：debug串口初始化之前需要添加JL_UART0->CON0  = BIT(0);确保通信串口不被debug串口占用

```
#define UART_CLK  clk_get("uart")
#define UART_OT_CLK  clk_get("lsb")
#define UART_BAUD    1000000
#define UART_RX_TIMEOUT    1000//ms 
#define UART    JL_UART0//JL_UT1
static u8 uart_tx_buff[128];__attribute__((aligned(4)));
static u8 uart_rx_buff[128];__attribute__((aligned(4)));
static void test_uart_set_dma_dir(u32 dir){
    if (dir) {
        JL_PORTB->DIR |=  BIT(5);
        UART->CON1 &= ~BIT(4);
    } else {
        UART->CON1 |= BIT(4);
        JL_PORTB->DIR &= ~BIT(5);
    } 
}
void test_uart_tx_data(u8 *buf, u32 len){
    test_uart_set_dma_dir(0);
    UART->TXADR = (u32)buf;
    UART->TXCNT = len;
    __asm__ volatile("csync");
    while ((UART->CON0 & BIT(15)) == 0) {   //TX IDLE
    }
    UART->CON0 |= BIT(13);
    test_uart_set_dma_dir(1);
}
int test_uart_rx_data(u32 addr, u32 len){
    wdt_clr();
    test_uart_set_dma_dir(1);
    UART->RXSADR = (u32)addr;
    UART->RXEADR = (u32)(((addr + len) + 3) / 4 * 4);
    /* UART->RXEADR = (u32)(addr + len); */
    UART->RXCNT = len;
    __asm__ volatile("csync");
    while (1) {
         if (UART->CON0 & (BIT(14) | BIT(11))) { 
        /* if (UART->CON0 & (BIT(11))) { */
        /*if (UART->CON0 & (BIT(14))) {*/
            break;
        }
    }
     UART->CON0 |= BIT(7);
     UART->CON0 |= BIT(10) | BIT(12);
     __asm__ volatile("csync");
     int rx_len = UART->HRXCNT;
    UART->CON0 |= BIT(12) | BIT(10);
    return rx_len;
}
void test_uart_init(){
    JL_IOMAP->CON0 &= ~(3 << 3); //ut0_c
    JL_IOMAP->CON0 |= (2 << 3);
    JL_IOMAP->CON3 |= (1 << 3);

    JL_PORTB->HD |=  BIT(5);
    JL_PORTB->PU |=  BIT(5);
    JL_PORTB->PD &= ~BIT(5);
    JL_PORTB->DIR |=  BIT(5);

    UART->CON0 = BIT(13) | BIT(12) | BIT(10);
    UART->CON0 = BIT(6) | BIT(0)| BIT(5);
    UART->CON0 |= BIT(13) | BIT(12) | BIT(10);
    UART->BAUD = (UART_CLK / UART_BAUD) / 4 - 1;

    u32 timeout=UART_RX_TIMEOUT;//ms
    UART->OTCNT = timeout * (UART_OT_CLK / 1000);//1000us
}
void test_uart_fun(void){
    wdt_close();
    test_uart_init();    
    sprintf(uart_tx_buff,"=================0x%x 0x%x 0x%x\r\n",JL_UART0->CON0,JL_UART1->CON0,JL_UART2->CON0);
    test_uart_tx_data(uart_tx_buff,sizeof(uart_tx_buff));
    int len=0;
    while (1){
        memset(uart_rx_buff,0,sizeof(uart_rx_buff));
        memset(uart_tx_buff,0,sizeof(uart_tx_buff));
        len=test_uart_rx_data(uart_rx_buff,32);
        test_uart_tx_data(uart_rx_buff,len);
        printf(uart_rx_buff);
    }
}
```



### 3.2.3. USB直连电脑做串口通讯

> 注：usb直连做串口通讯， 实际就是替换usb串口在线调音的回调

修改如下

1. 关pc、usb功能

![img20](/pic/20.png)

![img21](/pic/21.png)

2. 开在线调音功能并且选择TCFG_USB_COMM

![img22](/pic/22.png)

3. 修改usb 串口处理回调，改为自己的处理接口

![img23](/pic/23.png)

