# 6. AUDIO相关应用

## 6.1. 频响(频谱)接口函数

频响：当前声音下每个频点的声音大小

1、开启板级配置文件的功能 

![img162](/pic/162.png)

2、频响配置后，开机就会打开，位置：

![img163](/pic/163.png)

3、参数设置

![img164](/pic/164.png)

4、数据打印处：

单位数字 db，最大值不到 90

![img165](/pic/165.png)

注意点：以上获取频响都是获取DAC的数据去做的，在linein走模拟信号输入等情况时，会因为拿不到数据等情况，获取不了频响。



## 6.2. 音量控制

### 6.2.1. 音量调节接口

- **硬件音量控制（硬件数字，硬件模拟）**

```
// type: TYPE_DAC_AGAIN->模拟音量  TYPE_DAC_DGAIN->硬件数字音量
// ch  : BIT(0):FL     BIT(1):FR     BIT(2):RL     BIT(3):RR 
// gain: 模拟音量：一般(0~30)  数字音量(0~16384)
int audio_dac_vol_set(u8 type, u32 ch, u16 gain, u8 fade_en);    

//设置左声道 模拟音量
audio_dac_vol_set(TYPE_DAC_AGAIN, BIT(0), gain_l, fade);
//设置右声道 模拟音量
audio_dac_vol_set(TYPE_DAC_AGAIN, BIT(1), gain_r, fade);
//设置左声道 数字音量
audio_dac_vol_set(TYPE_DAC_DGAIN, BIT(0), gain_l ? DEFAULT_DIGTAL_VOLUME : 0, fade);
//设置右声道 数字音量
audio_dac_vol_set(TYPE_DAC_DGAIN, BIT(1), gain_r ? DEFAULT_DIGTAL_VOLUME : 0, fade);
```

- **数字音量控制（独立通道音量调节）**

每个解码通道独立音量

```
//每个解码通道都开启数字音量管理,音量类型为VOL_TYPE_DIGGROUP时要使能
#define SYS_DIGVOL_GROUP_EN     1//DISABLE

#define SYS_VOL_TYPE            VOL_TYPE_DIGGROUP
```

实际上使能了独立通道音量调节：会在开机的时候固定设置模拟音量跟数字音量

音乐音量 观察每个通道的音量可以打开以下打印：

![img166](/pic/166.png)

- **实际应用**

实现任意音量等级调节

步骤1：board文件选择，独立通道数字音量。

![img167](/pic/167.png)

步骤2：生成一个数字音量表

![img168](/pic/168.png)

步骤3：替换默认的音量表

![img169](/pic/169.png)



### 6.2.2. 音量级db值修改

如果使用硬件模拟音量调节，音量级对应DB值达不到需求。可以选择使用数字音量或联合音量调节，然后到配置工具中设置每个音量等级的db值，生成的音量表替换程序中的表：

![img170](/pic/170.png)

生成音量表的方法和上述第一点相同

替换到程序中数字音量表：

![img171](/pic/171.png)

替换到程序中的联合音量表：

![img172](/pic/172.png)



## 6.3. DAC

### 6.3.1 DAC 参数配置

```
struct dac_platform_data {
    u32 output : 4;             //DAC输出模式
    u32 ldo_volt : 4;           //DACVDD_LDO电压档选择
    u32 ldo_isel : 4;           //LDO偏置电流选择档位, 0:5u, 1:10u, 2:15u, 3:20u, 4:25u, 5:30u, 6:35u, 7:40u
    u32 lpf_isel : 4;           //LPF bias电流选择, 0:无, 1:0.3125u, 2:0.625u, 3:0.9375, 4:1.25u, 5:1.5625, 6:1.875u, 7:2.1875u, 8:2.5u, 9:2.8125u, 10:3.125u, 11:3.4375u, 12:3.75u, 13:4.0625u, 14:4.375u, 15:4.6875u
    u32 ldo_fb_isel : 2;        //LDO负载电流选择, 0:15u, 1:48u, 2:81u, 3:114u
    u32 vcmo_en : 1;            //VCMO直推使能
    u32 keep_vcmo : 1;
    u32 dsm_clk : 1;
    u32 vcm_risetime : 1;       //VCM上电快慢选择
    u32 zero_cross_detect : 1;  //模拟增益过零检测配置
    u32 vdd_setting_enable : 1; //通过接口设置DACVDD电压的使能
};

//****************
//SDK参数  参考配置
//****************
struct dac_platform_data dac_data = {
    .ldo_volt       = TCFG_AUDIO_DAC_LDO_VOLT,                   //DACVDD等级.需要根据具体硬件来设置（高低压）可选:1.2V/1.3V/2.35V/2.5V/2.65V/2.8V/2.95V/3.1V
#if ((TCFG_AUDIO_DAC_CONNECT_MODE == DAC_OUTPUT_FRONT_LR_REAR_LR) || (TCFG_AUDIO_DAC_CONNECT_MODE == DAC_OUTPUT_DUAL_LR_DIFF))
    .vcmo_en        = 0,                                         //四声道与双声道差分关闭VCOMO
#else
    .vcmo_en        = 1,                                         //是否打开VCOMO
#endif
    .output         = TCFG_AUDIO_DAC_CONNECT_MODE,               //DAC输出配置，和具体硬件连接有关，需根据硬件来设置
    .ldo_isel       = 3,
    .ldo_fb_isel    = 2,
    .lpf_isel       = 0x8,
};
```

当需要修改DAC的驱动电流时，建议是修改lpf_isel 这个参数

- output：DAC输出模式

```
#define DAC_OUTPUT_MONO_L                  0    //左声道
#define DAC_OUTPUT_MONO_R                  1    //右声道
#define DAC_OUTPUT_LR                      2    //立体声
#define DAC_OUTPUT_MONO_LR_DIFF            3    //单声道差分输出

#define DAC_OUTPUT_DUAL_LR_DIFF            6    //双声道差分
#define DAC_OUTPUT_FRONT_LR_REAR_LR        9    //四声道单端输出(不可设置vcmo公共端)
```

- 差分输出：有两个输出端，输出的信号是两输出端之间的电压差；
- 单端输出：只有一个输出端，输出的信号是输出端对地的电压。



### 6.3.2. AC696N系列设置DAC管脚高阻态

```
/*
ch: FL:BIT(0) FR:BIT(1) RL:BIT(2) RR:BIT(3)
例如：BIT(0)是 FL 左声道， BIT(1)是 FR 右声道， FLR BIT(0)|bit(1)是立体声
MUTE:1:MUTE 0:UNMUTE
*/
void audio_dac_mute_ch(u8 ch, u8 mute)
{
    if (mute) { 
        JL_ANA->DAA_CON1 &= ~((ch & 0x3) << 10);
        JL_ANA->DAA_CON1 &= ~((ch & 0x3) << 13);
    } else {
        JL_ANA->DAA_CON1 |= ((ch & 0x3) << 10);
        JL_ANA->DAA_CON1 |= ((ch & 0x3) << 13);
    }
} 
```



## 6.4. MIC

### 6.4.1. 打开MIC数据采样

示范程序

```
struct adc_mic_ch user_mic;
struct audio_adc_output_hdl user_mic_output;
/*----------------------------------------------------------------------------*/
/**@brief  MIC数据的回调
   @param
   @return
   @note ： 默认统计最大/最小值/最大最小的差
*/
/*----------------------------------------------------------------------------*/
static void my_adc_output_to_enc(void *priv, s16 *data, int len)
{
    //参数定义
    #define CALC_DATA_SUM 16000   //多长时间更新一次数据 
    
    u16 points = len / 2;
    u16 index;
    static s32 min = 0xfffff;
    static s32 max = -100000;
    static s32 cnt_sum = 0;
    s32 db = 0;

    for (index = 0; index < points; index ++) {
        db = data[index];
        cnt_sum++;
        if (cnt_sum > CALC_DATA_SUM) {
            printf("MAX : %d\tMIN : %d  \t: %d\n",max,min,max-min);
            cnt_sum = 0;
            min = 0xfffff;
            max = -100000;
        }
        if (min > db)
            min = db;
        if (max < db)
            max = db;
    }
}

/*----------------------------------------------------------------------------*/
/**@brief  打开MIC
   @param
   @return
   @note ： audio_mic_open 另外两个传参为 采样率 和 MIC增益
*/
/*----------------------------------------------------------------------------*/
void user_mic_open(void)
{
    user_mic_output.handler = my_adc_output_to_enc;
    user_mic_output.priv    = NULL;
    if (audio_mic_open(&user_mic, 16000,0) == 0) {
        audio_mic_add_output(&user_mic_output);
        audio_mic_start(&user_mic);
    }
}

/*----------------------------------------------------------------------------*/
/**@brief  关闭MIC
   @param
   @return
   @note
*/
/*----------------------------------------------------------------------------*/
void user_mic_close(void)
{
    audio_mic_close(&user_mic, &user_mic_output);
}
```



### 6.4.2. 打开mic，获取mic数据，分析mic频谱

```
//使用头文件
#include "spectrum/Spectrum_fft.h"
//数据定义
#define mic_spectrum_fft        1
int get_spectrum;
spectrum_fft_hdl *fft_hdl = NULL;


//开mic,获取mic数据：
extern void mic_spectrum_get_demo(void *p);
int audio_adc_mic_open_demo(u16 sr)                           
{    printf("KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKL\n");
    u8 ladc_mic_gain = 5;
    ASSERT(ladc_mic == NULL);
    ladc_mic = zalloc(sizeof(struct ladc_mic_demo));
    if (ladc_mic) {
        audio_adc_mic_open(&ladc_mic->mic_ch, AUDIO_ADC_MIC_CH, &adc_hdl);
        audio_adc_mic_set_sample_rate(&ladc_mic->mic_ch, sr);
        audio_adc_mic_set_gain(&ladc_mic->mic_ch, ladc_mic_gain);
        audio_adc_mic_set_buffs(&ladc_mic->mic_ch, ladc_mic->adc_buf, LADC_MIC_IRQ_POINTS * 2, LADC_MIC_BUF_NUM);
        audio_adc_mic_start(&ladc_mic->mic_ch);
        ladc_mic->adc_output.handler = adc_mic_open_demo_output;    //回调函数
        ladc_mic->adc_output.priv = &adc_hdl;
        audio_adc_add_output_handler(&adc_hdl, &ladc_mic->adc_output);
 #if mic_spectrum_fft                                              //频谱部分
        spectrum_fft_open_parm parm = {0};
        parm.sr = sr;
        parm.channel = 1;
        parm.attackFactor = 0.9;
        parm.releaseFactor = 0.9;
        parm.mode = 2;
        fft_hdl = audio_spectrum_fft_open(&parm);
        get_spectrum = sys_timer_add(fft_hdl, mic_spectrum_get_demo, 500);//频谱值获取测试 */
        printf("spectrum_open_demo\n");
        clock_add(SPECTRUM_CLK);
#endif
        return 0;
    } else {
        return -1;
    }
}
////MIC回调函数：
extern int audio_spectrum_fft_run(spectrum_fft_hdl *hdl, s16 *data, int len);
static void adc_mic_open_demo_output(void *priv, s16 *data, int len)
{
    struct audio_adc_hdl *hdl = priv;
    //putchar('o');
    if (ladc_mic == NULL) {
        return;
    }
#if mic_spectrum_fft                                  //频谱部分
    audio_spectrum_fft_run(fft_hdl,data,len);
#endif
   // printf("ppppp:%d,%d\n",data[2],len);                //可在此处拿到MIC采集的数据，对所有数据做绝对值累加则可以作为声音能量参考依据
}
///关MIC函数
void audio_adc_mic_close_demo(void)
{
    if (ladc_mic){
#if mic_spectrum_fft                                   //频谱部分
        audio_spectrum_fft_close(fft_hdl);
        clock_remove(SPECTRUM_CLK);
        sys_timer_del(get_spectrum);
#endif
        audio_adc_mic_close(&ladc_mic->mic_ch);
        audio_adc_del_output_handler(&adc_hdl, &ladc_mic->adc_output);
        free(ladc_mic);
        ladc_mic = NULL;
    }
}
```



```
//频谱数据处理函数涉及的头文件及参数：
#include "spectrum/spectrum_fft.h"
#include "audio_splicing.h"
#define spectrum_fft_points_per_ch  (512)
//频谱部分：
//上文获取频谱输出函数：
void mic_spectrum_get_demo(void *p)
{
    spectrum_fft_hdl *hdl = p;
    printf("spectrum_open_demo : %d\n",hdl);
    if (hdl) {
        u8 db_num = audio_spectrum_fft_get_num(hdl);//获取频谱个数
        short *db_data = audio_spectrum_fft_get_val(hdl);//获取存储频谱值得地址
        if (!db_data) {
            return;
        }
        for (int i = 0; i < db_num; i++) {
            //输出db_num个 db值
            printf("db_data db[%d] %d\n", i, db_data[i]);
        }
    }
}
//频谱数据处理函数：
/*----------------------------------------------------------------------------*/
/**@brief    audio_spectrum_fft_run 同步处理,每次run都会把输入buf消耗完，才会往下走
   @param    _hdl:句柄
   @param    data:输入数据
   @param    len:输入数据长度
   @return  len
   @note    频谱计算处理，只获取输入的数据，不改变输入的数据
*/
/*----------------------------------------------------------------------------*/
int audio_spectrum_fft_run(spectrum_fft_hdl *hdl, s16 *data, int len)
{
    if (!hdl) {
        return len;
    }
    if (!len) {
        return len;
    }

    if (!hdl->run_en) {
        hdl->offset = 0;
        return len;
    }

    u8 channel = (hdl->parm.channel & 0x3);
    s16 *indata_tmp = data;
    u32 in_remain = len;
    u32 tlen;
__here:
    indata_tmp = (s16 *)((int)data + (len - in_remain));
    if (hdl->offset < hdl->out_buf_size) {
        tlen = hdl->out_buf_size - hdl->offset;
        if (channel == 2 && (hdl->parm.channel & BIT(4))) {
            if (tlen > in_remain / 2) {
                tlen = in_remain / 2;
            }
            pcm_qual_to_dual((void *)((int)hdl->out_buf + hdl->offset), indata_tmp, tlen * 2);
            hdl->offset += tlen;
            in_remain -= tlen * 2;
        } else {
            if (tlen > in_remain) {
                tlen = in_remain;
            }
            memcpy((void *)((int)hdl->out_buf + hdl->offset), indata_tmp, tlen);
            hdl->offset += tlen;
            in_remain -= tlen;
        }
        if (in_remain && (hdl->offset != hdl->out_buf_size)) {
            goto __here;
        }
    }
    if (hdl->offset == hdl->out_buf_size) {
        hdl->offset = 0;
        SpectrumShowRun(hdl->work_buf, hdl->out_buf, spectrum_fft_points_per_ch);
        if (in_remain) {
            goto __here;
        }
    }
    return len;
}
参考按键使用例程：
extern int audio_adc_mic_open_demo(u16 sr);
extern void audio_adc_mic_close_demo(void);
case KEY_OPEN_ADC:
static int i = 0;
if(i == 0){
    printf("audio_adc_open_demo");
    audio_adc_mic_open_demo(44100);
    i = 1;
}
else{
    printf("audio_adc_close_demo");
    audio_adc_mic_close_demo();
    i = 0;
}
break;  
```

上文主要实现功能：当audio_adc_mic_open_demo函数执行后，将开启MIC，并采集MIC数据在adc_mic_open_demo_output回调函数处可以对收集到的数据做处理。同时如果将mic_spectrum_fft宏定义为1时，可以同时得到频谱的输出。



### 6.4.3. 打开MIC偏置接口

audio_adc.h

```
int audio_adc_mic_open(struct adc_mic_ch *mic, int ch, struct audio_adc_hdl *adc);
```



## 6.5. 音频流 

### 6.5.1. 人声消除

- 目前有以下情况目前不支持人声消除（可能会出现无声的情况）：

1. 左右声道数据基本一致的音频文件。

- 程序宏定义开关

```
//*********************************************************************************//
//                                人声消除使能
//*********************************************************************************//
#define AUDIO_VOCAL_REMOVE_EN       0

//*********************************************************************************//
//                                相关函数
//*********************************************************************************//
/*----------------------------------------------------------------------------*/
/**@brief    audio_vocal_remove_sw 运行过程开关处理
   @param    _hdl:句柄
   @param    dis: 0：人声消除有效  1:人声消除无效
   @return  0:成功  -1：失败
   @note
*/
/*----------------------------------------------------------------------------*/
int audio_vocal_remove_sw(vocal_remove_hdl *_hdl, u32 dis);
```



### 6.5.2. DAC能量值计算

通用能量值计算（取平均值）

```
#define ABS(x)                      (x > 0 ? x : (-x))
int audio_output_data_db_calc_simple(short *data, unsigned short len,unsigned char channels)
{
    //长度转换，如果长度是u8 需要/2
    unsigned short points = len / 2;
        unsigned short user_sample_rate = 16000;
    signed int  calc_point = user_sample_rate/50;
    static signed int  data_cnt = 0;
    static signed int  sum[4] = {0,0,0,0};
    static int average_value;

    int index = 0;

    for(index = 0; index < points; index+=channels) {
        //计算数值总和
        switch (channels) {
        case 4:
            sum[3] +=  ABS(data[index+3]);
        case 3:
            sum[2] +=  ABS(data[index+2]);
        case 2:
            sum[1] +=  ABS(data[index+1]);
        case 1:
            sum[0] +=  ABS(data[index]);
            break;
        default:
            sum[0] +=  ABS(data[index]);
            break;
        }
        data_cnt++;
        if(data_cnt>=calc_point) {
            //计算各通道取平均
            average_value= (sum[0]+sum[1]+sum[2]+sum[3])/(channels*calc_point);
            //printf("average_value:%d\n",average_value);
            sum[0] = 0;
            sum[1] = 0;
            sum[2] = 0;
            sum[3] = 0;
            data_cnt = 0;
        }
    }
    return average_value;
}
```

蓝牙模式下（参考例子）

拿到蓝牙解码数据后，对数据进行累加取平均值计算。得出能量值。（修改如下图）

![img173](/pic/173.png)



## 6.6. EQ

### 6.6.1 在线调试方法

- 见第10节EQ相关文档



### 6.6.2. 离线调试方法

与在线调试方法不一样的地方是，需要注意SDK的EQ版本，工具上要对应选择。

![img174](/pic/174.png)

![img175](/pic/175.png)



### 6.6.3. EQ切换

**测试代码**

```
#define your_EQ_FILE_NAME           SDFILE_RES_ROOT_PATH"eq_cfg_h2.bin"
#define your_EQ_FILE_NAME1          SDFILE_RES_ROOT_PATH"eq_cfg_h1.bin"
void user_eq_change(void)
{
    s32 ret = 0;
    static u8 flag = 0;
    if(flag){
        flag = 0;
        eff_file_switch(your_EQ_FILE_NAME);
    }
    else{
        flag = 1;
        eff_file_switch(your_EQ_FILE_NAME1);
    }
}
```

**自定义系数表动态更新**

```
//系数切换
void eq_sw_demo()
{
    eq_mode_sw();//7种默认系数切换
}

//获取当前eq系数表类型
void eq_mode_get_demo()
{
    u8 mode ;
    mode = eq_mode_get_cur();
}
//宏TCFG_USE_EQ_FILE配0
//自定义系数表动态更新
//本demo 示意更新中心截止频率，增益，总增益，如需设置更多参数，请查看eq_config.h头文件的demo
void eq_update_demo()
{
    eq_mode_set_custom_info(0, 200, 2);//第0段,200Hz中心截止频率，2db
    eq_mode_set_custom_info(5, 2000, 2);//第5段,2000Hz中心截止频率，2db

    set_global_gain(get_eq_cfg_hdl(), song_eq_mode, -2);//设置普通音乐eq 总增益 -2db（可避免最大增益大于0db，导致失真）

    eq_mode_set(EQ_MODE_CUSTOM);//设置系数、总增益更新
}
```



## 6.7. MP3文件无缝播放

要使用该功能确保以下宏有打开

```
#define FILE_DEC_REPEAT_EN            1//0 // 无缝循环播放

#define TCFG_DEC_MP3_ENABLE           1//0
```

需要保证播放时不能进入低功耗，最好取消进入低功耗的配置宏和蓝牙没有连接自动关机的宏（当然也可以自行根据需求去控制）

```
#define TCFG_LOWPOWER_LOWPOWER_SEL            0//1   //芯片是否进入powerdown

#define TCFG_AUTO_SHUT_DOWN_TIME              0//180   //没有蓝牙连接自动关机时间
```

![img176](/pic/176.png)



## 6.8. 变速变调

宏定义：

```
//696
#define TCFG_SPEED_PITCH_ENABLE             DISABLE
```

![img177](/pic/177.png)

变速有具体的换算方法

```
static int get_speedV(float speed)
{
    int speedV;
    if (speed >= 1) {
        //变快
        speedV = (256 - 256 / speed) * 80 / 140 + 80;
    } else {
        //变慢
        speedV = 80 - (256 / speed) * 80 / 450;
    }
    return speedV;
}
```