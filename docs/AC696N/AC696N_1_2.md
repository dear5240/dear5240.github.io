# 2. TIMER

## 2.1. 概述

Timer是一个集合了定时/计数/捕获功能于一体的多功能定时器。

它的驱动源可以选择**片内时钟或片外信号**。

它带有一个可配置的最高达 64 的**异步预分频器**， 用于扩展定时时间或片外信号的最高频率。 

它还具有上升沿/下降沿**捕获功能**，可以方便的对片外信号的高电平/低电平宽度进行测量。

- 芯片产品介绍

| 芯片   | 位数 | 捕获模式  | 反向输出 | IOMAP |
| ------ | ---- | --------- | -------- | ----- |
| AC696X | 32   | 向上/向下 | 有       | 支持  |



## 2.2. 系统定时器

系统定时器文档链接：[系统定时器接口](https://www.kdocs.cn/l/chZlzbzCwGjm?openfrom=docs)



## 2.3. 寄存器说明

![img10](/pic/10.png)

![img11](/pic/11.png)

![img12](/pic/12.png)

![img13](/pic/13.png)



## 2.4. 定时器应用

### 2.4.1. 定时功能

此处以696，led7_timer.c文件举例

```
static void timer2_isr()
{
    //local_irq_disable();     //需要极准确的定时效果时开启
    TIMER_CON |= BIT(14);      //清中断标志位
    //用户自定义代码
    //......
    //local_irq_enable();      //需要极准确的定时效果时开启
}

int led7_timer_init()
{
    u32 prd_cnt;
    u8 index;

    printf("------------%s :%d", __func__, __LINE__);

    for (index = 0; index < (sizeof(timer_div) / sizeof(timer_div[0])); index++) {
        prd_cnt = TIMER_UNIT_MS * (APP_TIMER_CLK / 1000) / timer_div[index];
        if (prd_cnt > MIN_TIME_CNT && prd_cnt < MAX_TIME_CNT) {
            break;
        }
    }
    __this->index   = index;
    __this->prd     = prd_cnt;

    TIMER_CNT = 0;
    TIMER_PRD = prd_cnt; //1ms
    request_irq(TIMER_VETOR, 6, timer2_isr, 0); //最高优先级7,需要极准确的定时效果时开启
    TIMER_CON = (index << 4) | BIT(0) | BIT(3);

    printf("PRD : 0x%x / %d", TIMER_PRD, clk_get("timer"));

    return 0;
}
```



### 2.4.2. 捕捉功能

- 参考代码

```
//基于696程序  存在一些IO口无法做此功能，先测试，再画板 ！！！！！！
#define TIMER5                      7 //见irflt.h
#define CATCH_TIMER                 TIMER5
#define CATCH_IRQ_TIME_IDX          IRQ_TIME5_IDX
#define CATCH_TIME_REG              JL_TIMER5
#define CATCH_GPIO                  IO_PORTB_06
int num = 0;
void timer_ms()
{
    static int flag = 0;
    if(flag){
        gpio_set_pull_down(IO_PORTA_02,0);
        gpio_set_pull_up(IO_PORTA_02,0);
        gpio_set_direction(IO_PORTA_02,1);
        flag = 0;
    }
    else{
        gpio_set_pull_down(IO_PORTA_02,0);
        gpio_set_pull_up(IO_PORTA_02,0);
        gpio_set_direction(IO_PORTA_02,0);
        gpio_set_output_value(IO_PORTA_02,0);
        putchar('0');
        flag = 1;        
    }
}
___interrupt
void timer_catch_isr(void)
{
    CATCH_TIME_REG->CON |= BIT(14);
    u16 bCap1 = CATCH_TIME_REG->PRD;     //上次中断到这次的时间，可以用于计时
    CATCH_TIME_REG->CNT = 0;
    num++;                               //计数
}

void timer_100ms()
{
    printf("num == %d\n",num);
    num = 0;
}

void timer_catch_init()
{
    printf("timer_catch_init\n");
    //IO口配置
    gpio_irflt_in(CATCH_GPIO);
    gpio_set_direction(CATCH_GPIO, 1);
    gpio_set_die(CATCH_GPIO, 1);
    gpio_set_pull_up(CATCH_GPIO, 1);
    gpio_set_pull_down(CATCH_GPIO, 0);
    //设置时钟
    SFR(JL_IOMAP->CON0, 5, 3, CATCH_TIMER);                           //TIMER5:7  irflt.h
    CATCH_TIME_REG->CON = 0;
    CATCH_TIME_REG->CON |= (0b10 << 2);                        //选择晶振时钟源：24MHz
    CATCH_TIME_REG->CON |= (0b0001 << 4);                    //时钟源4分频
    //设置周期，初始值，定时器模式
    CATCH_TIME_REG->PRD = OSC_Hz / (4 * 1000);
    CATCH_TIME_REG->CNT = CATCH_TIME_REG->PRD;
    CATCH_TIME_REG->CON |= BIT(14);
    CATCH_TIME_REG->CON |= (0b11 << 0);
    request_irq(CATCH_IRQ_TIME_IDX, 5, timer_catch_isr, 0);
    sys_timer_add(NULL,timer_100ms,100);                    //定时读取中断次数
    sys_timer_add(NULL,timer_ms,1);                         //设置生成波形，供中断采集，不准，非1ms
}
```

