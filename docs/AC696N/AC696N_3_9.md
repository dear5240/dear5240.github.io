# 9. UI相关应用

## 9.1. 128*64点阵液晶模块 （黑白屏）

![img190](/pic/190.png)

**程序配置**

- 配置UI相关配置

宏配置

```
//*********************************************************************************//
//                                  UI 配置                                        //
//*********************************************************************************//
#define TCFG_UI_ENABLE                         ENABLE_THIS_MOUDLE     //UI总开关
#define CONFIG_UI_STYLE                     STYLE_JL_SOUNDBOX
// #define CONFIG_UI_STYLE                  STYLE_UI_SIMPLE //这是309 sdk ui 风格 需要再开启TCFG_SIMPLE_LCD_ENABLE
// #define TCFG_UI_LED7_ENABLE                  ENABLE_THIS_MOUDLE     //UI使用LED7显示
// #define TCFG_UI_LCD_SEG3X9_ENABLE         ENABLE_THIS_MOUDLE     //UI使用LCD段码屏显示
// #define TCFG_LCD_ST7735S_ENABLE            ENABLE_THIS_MOUDLE
// #define TCFG_LCD_ST7789VW_ENABLE            ENABLE_THIS_MOUDLE
#define TCFG_LRC_LYRICS_ENABLE              ENABLE_THIS_MOUDLE  //歌词显示
#define TCFG_LCD_OLED_ENABLE                ENABLE_THIS_MOUDLE
#define TCFG_SPI_LCD_ENABLE                 ENABLE_THIS_MOUDLE //spi lcd开关
#define TCFG_SIMPLE_LCD_ENABLE              DISABLE_THIS_MOUDLE//去ui 框架的驱动开关 开启请关闭了TCFG_SPI_LCD_ENABLE
#define TCFG_TFT_LCD_DEV_SPI_HW_NUM             1// 1: SPI1    2: SPI2 配置lcd选择的spi口
#define LCD_SPI_INTERRUPT_ENABLE             0//默认开启 需要主动关闭
#define ALL_KEY_EVENT_CLICK_ONLY             1     //是否全部按键只响应单击事件
```

IO配置

```
#if (TCFG_SPI_LCD_ENABLE || TCFG_SIMPLE_LCD_ENABLE)

LCD_SPI_PLATFORM_DATA_BEGIN(lcd_spi_data)

#if TCFG_LCD_OLED_ENABLE
    .pin_reset    = IO_PORTC_01,
    .pin_cs        = IO_PORTC_03,
    .pin_rs        = IO_PORTC_02,
    .pin_bl     = IO_PORTC_00,
#else
    .pin_reset    = -1,
    .pin_cs        = IO_PORTC_03,
    .pin_rs        = IO_PORTC_02,
    .pin_bl     = IO_PORTC_01,
#endif

#if (TCFG_TFT_LCD_DEV_SPI_HW_NUM == 1)
    .spi_cfg    = SPI1,
    .spi_pdata  = &spi1_p_data,
#elif (TCFG_TFT_LCD_DEV_SPI_HW_NUM == 2)
    .spi_cfg    = SPI2,
    .spi_pdata  = &spi2_p_data,
#endif
LED7_PLATFORM_DATA_END()

const struct ui_devices_cfg ui_cfg_data = {
    .type = TFT_LCD,
    .private_data = (void *)&lcd_spi_data,
};
#endif
```

- 液晶屏初始化代码

根据使用的屏的驱动自行修改

```
//初始化SSD1306
static void SPI_OLED_Init(void)
```

- 不同规格液晶屏大小修改

```
#define SCR_X 0        ///屏幕起始点X的偏移
#define SCR_Y 0        ///屏幕起始点Y的偏移
#define SCR_W 128       ///刷新屏幕的宽度，与LCD_W 一致
#define SCR_H 64        ///刷新屏幕的高度，与LCD_H 一致
#define LCD_W 128       
#define LCD_H 64
#define LCD_BLOCK_W 128    //显存buf的大小设定
#define LCD_BLOCK_H 64     //显存buf的大小设定
#define BUF_NUM 2           ///buf 数量
```



## 9.2. 单线串行控制幻彩灯珠

**思路**

- 颜色数据(R G B)->SPI数据->do(数据)引脚模拟灯珠通信协议

**要点**

- 确保spi的数据发送的精确度，系统时钟跑最高、spi时钟跑最高
  - 系统时钟：AC695N最高240MHz、AC696N最高192MHz
  - spi时钟：如果库里面没有做限制可以设置为 80MHz
- 发送数据时，用最后一个字节的第7位来控制发送完数据之后do引脚的高低电平
  - 最后一个字节的bit7为1，发送完数据之后do引脚为高电平，反之亦然。



**灯珠资料**

1、芯片级联方法

![img191](/pic/191.png)

2、数据传输

![img192](/pic/192.png)

注：其中 D1 为 MCU 端发送的数据，D2、D3、D4 为级联电路自动整形转发的数据

3、24bit 数据结构

![img193](/pic/193.png)

注：高位先发，按照 GRB 的顺序发送数据

4、时序波形

![img194](/pic/194.png)

5、通信信号传输定义

| ***参数名称***      | ***参数符号*** | ***最小值*** | ***典型值*** | ***最大值*** | ***单位*** |
| ------------------- | -------------- | ------------ | ------------ | ------------ | ---------- |
| 输入 0 码高电平时间 | Tin0h          | 0.20         | 0.28         | 0.35         | us         |
| 输入 1 码高电平时间 | Tin1h          | 0.65         | 0.9          | 1.0          | us         |
| 输入 0 码低电平时间 | T0L            | 1.55         | 1.72         | 30           | us         |
| 输入 1 码低电平时间 | T1L            | 1.10         | 1.10         | 30           | us         |
| 0 码/1 码周期       | T0/T1          | 1.75         | -            | 35           | us         |
| RESET 码低电平时间  | reset          | 100          | 150          | -            | us         |

注：

a：5050RGB 主要根据高电平时间判断“0”码和“1”码。高电平时间介于 200ns~410ns,IC 判断为“0”码,高电平时间介于 640ns~1000ns,判断为“1”码。 “0”码和“1”码的低电平代表此码结束，准备接收下一数据码。

b：低电平复位时间最小为 100us，为了留有裕度，一帧数据传输过程中(包括 24bit 和 24bit 之间、bit 和 bit 之间)不要中断超过 35us，否则可能会被 IC 认为是 RESET。中断时间在 35us 之内， 控制器可以进行正常数据传输等其他操作。



**步骤**

- spi波特率
  - spi数据发送0x55使用逻辑分析仪看数据高低电平翻转时间T
  - 需要同时满足
    - 码元周期(T0H+T0L或者T1H+T1L)=T*8
    - spi发送数据时高低电平翻转的时间T，必须满足:T0H=T**n1,T0L=T**(8-n1);T1H=T**n2,T1L=T**(8-n2)
    - n1、n2取值1-7
- 转换码
  - 使用一个字符spi的发送时间来模拟0码/1码的时序波形
  - 字符bit中1/0控制0码/1码时序波形的高和低
  - 字符bit中连续的1/0控制0码/1码时序波形的高和低持续时间



eg:

> ​	如《5. 通信信号传输定义》T0H 取值范围是0.20us-0.35us T0L 取值范围是1.55us-30us 满足以上两点
>
> ​	T=0.3us
>
> ​	n1=7 T0H:T0L=1:7
>
> ​	n2=5 T1H:T1L=5:3

​	0码：0X80

​	1码：0XF8

​	也就是说spi发送0X80就是发送了0码，发送0XF8就是发送1码

- 优化转换码
  - spi硬件上发送数据时每两个字节中间会有一个时间间隔
  - 发送每个字符第一bit的时间不是很精确

![img195](/pic/195.png)

以上两个因素可以使用码元的低电平对时间敏感度低（码元的低电平时间容错时间长）这个特性改善对模拟的波形进行优化。

实际操作就是发送字符的7bit和0bit为0，可以把字符数据整体右移一个bit。

原来的0码0X80变为0X40

原来的1码0XF8变为0X7C



验证spi发送数据是否符合灯的规格：

![img196](/pic/196.png)



**代码注意点**

696 170SDK本身有led spi驱动在led_spi.c文件中。

幻彩灯珠驱动在ledc_test.c中：

![img197](/pic/197.png)



## 9.3. LED7数码管

**板极配置**

![img221](/pic/221.png)

**引脚配置**

![img222](/pic/222.png)

**真值表配置**

![img223](/pic/223.png)

**LED7数码管API接口**

![img224](/pic/224.png)



**使用方式：**

- 每个模式的数码管显示单独一个.c文件

![img225](/pic/225.png)

- 设置显示内容（ui_bt.c为例）

![img226](/pic/226.png)