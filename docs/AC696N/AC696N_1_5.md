# 5. IIC

## 5.1. IO口及其他配置定义

![img27](/pic/27.png)



## 5.2. IIC基础使用函数

此处以696的软件IIC举例，同时也建议客户使用软件IIC来进行IIC各项操作。

函数文件：iic_soft.c   iic_soft.h

![img28](/pic/28.png)



## 5.3. IIC一般使用方式

![img29](/pic/29.png)

\#define WRITEORDER                          0x58                       //写命令

\#define READORDER                           0x59			    //读命令

```
参考使用方式
//指定寄存器地址写一个字节
u8 I2C_write_byte(u8 writeAddr,u8 byte)
{
    u8 ret = 0;
    iic_start(iic);                             //I2C启动
    ret += iic_tx_byte(iic, WRITEORDER);          //写命令
    ret += iic_tx_byte(iic,writeAddr);             //写地址
    ret += iic_tx_byte(iic,byte);               //写一个字节
    iic_stop(iic);                             //产生一个停止条件
    if(ret < 3){
        return 1;
    }
    else{
        return 0;
    }
}
 
//指定寄存器地址读一个字节
u8 I2C_read_byte(u8 readaddr)
{
    u8 ret = 0;
    u8 data = 0;
    iic_start(iic);                               //I2C启动
    ret += iic_tx_byte(iic, WRITEORDER);         //写命令
    ret += iic_tx_byte(iic,readaddr);            //read地址
    iic_stop(iic);                                //I2C停止
    iic_start(iic);                                //I2C启动(写转为读命令，需要再次启动I2C)
    ret += iic_tx_byte(iic, READORDER);            //读命令
    data = iic_rx_byte(iic, 0);                 //读操作
    iic_stop(iic);                                //产生一个停止条件
    if(ret < 3){
        return 1;
    }
    else{
        return data;
    }
}
 
 
/**********************************************************
//在指定地址写入数据
//writeset_addr  :写入数据的器件地址
//writeAddr      :寄存器地址
//buf            :要写入的数据
//len            :写入的长度
**********************************************************/
u8 IIC_write_reg(char writeset_addr,char writeAddr,const void *buf, int len)
{
    u8 ret = 0;
    u8 i = 0;
    u8 ack = 0;
    iic_start(iic);                             //I2C启动
    ret += iic_tx_byte(iic, writeset_addr);     //写器件地址
    ret += iic_tx_byte(iic,writeAddr);          //写寄存器地址
    for (i = 0; i < len; i++) {
        ret += iic_tx_byte(iic, ((char *)buf)[i]);
    }
    iic_stop(iic);                              //产生一个停止条件
    if(ret < len+2){
        return 1;
    }
    else{
        return 0;
    }
}

 
/**********************************************************
//读指定地址的数据
//readaddr  :读取数据的目的地址
//buf       :读出的数据
//len       :读出数据的长度z
**********************************************************/
u8 I2C_read_reg(u8 readaddr,void *buf, int len)
{
    u8 ret = 0;
    iic_start(iic);                               //I2C启动
    ret += iic_tx_byte(iic, WRITEORDER);          //写命令
    ret += iic_tx_byte(iic,readaddr);             //read地址
    iic_stop(iic);                                //I2C停止
    iic_start(iic);                               //I2C启动(写转为读命令，需要再次启动I2C)
    ret += iic_tx_byte(iic, READORDER);           //读命令
    iic_read_buf(iic, &buf, len);                 //读操作
    iic_stop(iic);                                //产生一个停止条件
    if(ret < 3){
        return 1;
    }
    else{
        return 0;
    }
}
```



## 5.4. IIC做从机参考资料

[69系列iic从机参考资料](https://www.kdocs.cn/view/l/cqXx6e78oinu?openfrom=docs)