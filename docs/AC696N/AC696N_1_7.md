# 7. PWM

## 7.1. 重要参数介绍

PWM波形最重要的两个参数为：频率，占空比。

占空比：一个周期内高电平占整个周期的时间比。

![img30](/pic/30.png)

如图，高电平的时间（1ms) + 低电平的时间（3ms） = 4ms（一个周期）

频率 = 1s / 4ms = 250HZ

高电平时间 / 一个周期时间 = 1ms / 4ms = 25%（占空比）



## 7.2. PWM频率和占空比精度的关系

PWM波形一般由一个固定的时钟控制产生，一般时钟的频率是固定的，所以有以下关系： 时钟 = 频率 * 周期时间。

周期时间：就是一个周期内可以改变的精度，如果一个周期内有100个时间点，那占空比控制的精度就是1/100。

所以当提高频率时，占空比控制的精度就会下降。



## 7.3. 如何产生PWM波形

使用mcpwm.c文件的timer_pwm_init函数产生。

timer_pwm_init函数介绍：

```
#define     OSC_Hz      24000000
/**
 * @param JL_TIMERx : JL_TIMER0/1/2/3/4/5
 * @param fre : 频率，单位Hz，不小于95
 * @param duty : 初始占空比，0~10000对应0~100%
 * @param port : pwm脚，可选硬件脚，也可选非硬件脚。(建议选择硬件引脚)
 * @param output_ch : 映射通道，当pwm脚选择非硬件脚时有效，这时我们给他分配output_channel 0/1/2
 */
int timer_pwm_init(JL_TIMER_TypeDef *JL_TIMERx, u32 fre, u32 duty, u32 port, int output_ch)
{
    u32 hw_port;
    switch ((u32)JL_TIMERx) {
    case (u32)JL_TIMER0 :
        hw_port = IO_PORTA_05;
        break;
    case (u32)JL_TIMER1 :
        hw_port = IO_PORTC_04;
        break;
    case (u32)JL_TIMER2 :
        hw_port = IO_PORTB_03;
        break;
    case (u32)JL_TIMER3 :
        bit_clr_ie(IRQ_TIME3_IDX);
        hw_port = IO_PORTB_05;
        break;
    case (u32)JL_TIMER4 :
        hw_port = IO_PORTA_01;
        break;
    case (u32)JL_TIMER5 :
        hw_port = IO_PORTB_07;
        break;
    default:
        return (-1);
    }
    if ((output_ch == (-1)) && (hw_port != port)) {
        //not support output_ch
        return (-1);
    }

    //初始化timer
    JL_TIMERx->CON = 0;
    JL_TIMERx->CON |= (0b10 << 2);                      //选择晶振时钟源：24MHz
    JL_TIMERx->CON |= (0b0001 << 4);                    //时钟源4分频
    JL_TIMERx->PRD = OSC_Hz / (4 * fre);                //设置周期
    JL_TIMERx->PWM = (JL_TIMERx->PRD * duty) / fre; //0~10000对应0~100g
    JL_TIMERx->CNT = 0;                                 //清计数值
    JL_TIMERx->CON |= (0b01 << 0);                      //计数模式

    if (hw_port == port) {
        gpio_set_die(hw_port, 1);
        gpio_set_pull_up(hw_port, 0);
        gpio_set_pull_down(hw_port, 0);
        gpio_set_direction(hw_port, 0);
        JL_TIMERx->CON |= BIT(8);                       //PWM使能
    } else {
        gpio_output_channle(port, output_ch);
        return 1;
    }
    return 0;
}
```

参数输入如上图所示，注意点如下：

1、每个定时器都对应一个固定的IO口，如TIMER1->IO_PORTA_12,如果在芯片上能找到对应定时器的对应脚则优先使用。没有对应IO口的情况下，则可以任选一个IO口，然后通过通道映射的方式来使选择的IO口产生PWM。

示例：

```
timer_pwm_init(JL_TIMER3, 2000, 5000, IO_PORTB_05, 0);   //对应IO口产生

timer_pwm_init(JL_TIMER3, 2000, 5000, IO_PORTB_04, CH2_T3_PWM_OUT);  //通道映射
```

通道可以在gpio.h文件查询到，CHx_Tn_PWM_OUT,x代表通道x，n代表定时器，每个通道只能映射一个IO口，定时器必须跟选择的定时器一致。

*备注：定时器无论是正常对应IO口输出，映射输出都只会产生一个PWM波形，由最后执行的函数为准，且映射输出时，定时器对应的IO口也会产生对应波形，所以最优先选择定时器对应的IO口，避免造成IO口浪费。*

 

2、占空比，公版代码的占空比输入不是0-1000控制0-100%，如果需要改成此效果改此处：

```
JL_TIMERx->PWM = (JL_TIMERx->PRD * duty) / 10000;   //0~10000对应0~100%
```



3、时钟选择：

```
JL_TIMERx->CON = (0b10 << 2);                      //选择晶振时钟源：24MHz
```

公版SDK默认选择晶振时钟源，695，696均为24MHZ。

695，696的系统时钟源一般会比晶振时钟源的时钟高，695为60MHZ，如果需要产生高频率的PWM波形时可以改为系统时钟源。



4、产生PWM波形失败的可能原因：

(1) IO口被其他地方占用，程序是按前文配置，选择的IO口没有输出对应的波形时，可以通过代码编辑搜索看看是否IO口被其他地方占用；

(2) 定时器被占用，一般这种情况会导致程序复位或者死机。一般**TIMER1为系统自己本身使用的时钟**，不建议使用。**TIMER2默认用于UI显示**，建议关掉UI显示再使用TIMER2；



## 7.4. PWM问题点

**1. 初始化PWM时闪灯解决方法**

![img31](/pic/31.png)



**2. 消除占空比变为0时的一周期的高电平时间问题**

```
void set_timer_pwm_duty(JL_TIMER_TypeDef *JL_TIMERx, u32 duty)
{
    if(duty == 0){
        if(JL_TIMERx->PWM == 0){
            return;
        }
        //计时标志，进来此函数前PB3已经设置为高电平，PB3部分控制可省略
        JL_PORTB->OUT &= ~BIT(3);
        /*周期内低电平时期进入此函数，强制延长半个到一个周期等下一个周期下降沿再触发，
        防止一个周期最后1us左右时间触发此函数导致的程序执行时间不够导致极短时间的高电平*/
        if(JL_TIMERx->CNT > JL_TIMERx->PWM){
            while(JL_TIMERx->CNT > JL_TIMERx->PWM){
                delay(1);
            }
            while(JL_TIMERx->CNT < JL_TIMERx->PWM){
                delay(1);
            }
        }
        //周期内高电平时间进入此函数，等周期内低电平时间触发
        while(JL_TIMERx->CNT < JL_TIMERx->PWM){
            delay(1);
        }
        //关闭PWM波形
        JL_TIMERx->CON &= ~BIT(8);
        //时间标志
        JL_PORTB->OUT |= BIT(3);
    }
    else{
        //开启PWM
        JL_TIMERx->CON |= BIT(8);
    }
    JL_TIMERx->PWM = (JL_TIMERx->PRD * duty) / 10000;    //0~10000对应0~100% 
    //时间标志
    JL_PORTB->OUT &= ~BIT(3);
}


void timer_pwm_test(void) 
{ 
    //PB3为了计时设置，可以去掉
    gpio_set_pull_down(IO_PORTB_03,0);
    gpio_set_pull_up(IO_PORTB_03,0);
    gpio_set_direction(IO_PORTB_03,0);
    timer_pwm_init(JL_TIMER3, 100000, 2000, IO_PORTB_05, 0); 
} 

//测试按键消息
    case KEY_SET_PWM:
         log_info("KEY_SET_PWM\n");
         static int pwm_flag = 0;
         JL_PORTB->OUT |= BIT(3);
         if(pwm_flag){
            set_timer_pwm_duty(JL_TIMER3,0);
            pwm_flag = 0;
         }
         else{  
            set_timer_pwm_duty(JL_TIMER3,5000);
            pwm_flag = 1;            
         }
        break;
```

问题波形1（占空比变为0时1周期的高电平）：

![img32](/pic/32.png)

问题波形2（周期末尾操作寄存器执行时间不够导致波形顺延到下周期才执行）：

![img33](/pic/33.png)

