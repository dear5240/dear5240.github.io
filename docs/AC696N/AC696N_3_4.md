# 4. PC相关应用

USB (Universal Serial Bus，USB)，又称为通用串行总线。

USB模式分为主机模式和从机模式，当做为主机模式的时候，常见应用是去识别U盘，杰理芯片去主动访问U盘设备。当做为从机模式，常见应用就非常多，例如多功能蓝牙音箱，type-c耳机，读卡器等。



## 4.1. 代码结构

在`app_main.c`中会进入到`app_pc_task()`，该模式用于linein功能

应用端开发重点关注`..\SDK\apps\common\usb` 文件夹下的源文件，

```
..\cpu\br25\audio_dec`文件夹下的`audio_dec_pc.c和audio_dec_pc.h
```

其中 `usb_std_class_def.h` 定义各设备类的属性，`usb_common_def.h`用于定义 USB公共属性配置

`..\apps\common\usb\device` 是USB从机的驱动代码，例如CDC，HID，MSD等

.`.\apps\common\usb\host` 是 USB主机的驱动代码，例如adb,aoa,hid等。



## 4.2. 常见问题以及功能示例

### 4.2.1. USB设备类功能开关

```
#define     USB_DEVICE_CLASS_CONFIG (SPEAKER_CLASS|MIC_CLASS|HID_CLASS|MASSSTORAGE_CLASS)
```

- SPEAKER_CLASS：USB音频
- MIC_CLASS：USB音频
- HID_CLASS ：人机交互类，常用于控制UAC的音量调节、上下曲功能



### 4.2.2. USB描述符

**修改电脑上显示的名称**

修改以下数组。

格式如下：

第1位数据：描述符长度。这里填整个描述符数组的长度；

第2位数据：字符串述符，类型为0x03

第3~n位数据：数据

```
static const u8 user_stirng[] = {
    24,
    0x03,
    'U', 0x00,
    'S', 0x00,
    'B', 0x00,
    'A', 0x00,
    'u', 0x00,
    'd', 0x00,
    'i', 0x00,
    'o', 0x00,
    '2', 0x00,
    '.', 0x00,
    '0', 0x00,
};
```

- 参考例子

USB

```
static const u8 user_stirng[] = {
    8,
    0x03,
    'U', 0x00,
    'S', 0x00,
    'B', 0x00,
};
```

USB2.0

```
static const u8 user_stirng[] = {
    14,
    0x03,
    'U', 0x00,
    'S', 0x00,
    'B', 0x00,
    '2', 0x00,
    '.', 0x00,
    '0', 0x00,
};
```

中文修改需要使用unicode编码：

![img138](/pic/138.png)

测试：

```
static const u8 user_stirng[] = {
    6,
    0x03,
    0x4B, 0x6D,
    0xD5, 0x8B,
};
```



**PID&VID**

![img139](/pic/139.png)

**iserialnumber**

```
void get_iserialnumber_str(u8 *ptr)
{
#if USB_ROOT2
    memcpy(ptr, serial_string, serial_string[0]);
#else
    extern __attribute__((weak)) u8 *get_norflash_uuid(void);
    u8 flash_id[16] = {0};
    int i;
    u8 bcd;
    if (get_norflash_uuid && get_norflash_uuid()) {
        ptr[0] = 0x22;
        ptr[1] = 0x03;
        memset(&ptr[2], 0, 0x20);
        memcpy(flash_id, get_norflash_uuid(), 16);
        //take 8 bytes from flash uuid
        for (i = 0; i < 8; i++) {
            bcd = flash_id[i] >> 4;
            if (bcd > 9) {
                bcd = bcd - 0xa + 'A';
            } else {
                bcd = bcd + '0';
            }
            ptr[2 + i * 4] = bcd;
            bcd = flash_id[i] & 0xf;
            if (bcd > 9) {
                bcd = bcd - 0xa + 'A';
            } else {
                bcd = bcd + '0';
            }
            ptr[2 + i * 4 + 2] = bcd;
        }
    } else {
        memcpy(ptr, serial_string, serial_string[0]);
    }
#endif
}
```

**其他**

```
static const u8 LANGUAGE_STR[] = {
    0x04, 0x03, 0x09, 0x04
};
static const u8 product_string[] = {
    24,
    0x03,
    'U', 0x00,
    'A', 0x00,
    'C', 0x00,
    'D', 0x00,
    'e', 0x00,
    'm', 0x00,
    'o', 0x00,
    'V', 0x00,
    '1', 0x00,
    '.', 0x00,
    '0', 0x00,
};
static const u8 MANUFACTURE_STR[] = {
    34,         //该描述符的长度为34字节
    0x03,       //字符串描述符的类型编码为0x03
    0x4a, 0x00, //J
    0x69, 0x00, //i
    0x65, 0x00, //e
    0x6c, 0x00, //l
    0x69, 0x00, //i
    0x20, 0x00, //
    0x54, 0x00, //T
    0x65, 0x00, //e
    0x63, 0x00, //c
    0x68, 0x00, //h
    0x6e, 0x00, //n
    0x6f, 0x00, //o
    0x6c, 0x00, //l
    0x6f, 0x00, //o
    0x67, 0x00, //g
    0x79, 0x00, //y
};
const u8 speakerStringDescriptor[20] = {
    20,         //该描述符的长度为20字节
    0x03,       //字符串描述符的类型编码为0x03
    'U', 0x00, //U
    'S', 0x00, //S
    'B', 0x00, //B
    ' ', 0x00, //
    'A', 0x00, //A
    'u', 0x00, //u
    'd', 0x00, //d
    'i', 0x00, //i
    'o', 0x00, //o
};
static const u8 micStringDescriptor[30] = {
    30,         //该描述符的长度为30字节
    0x03,       //字符串描述符的类型编码为0x03
    'U', 0x00, //U
    'S', 0x00, //S
    'B', 0x00, //B
    ' ', 0x00, //
    'M', 0x00, //M
    'i', 0x00, //i
    'c', 0x00, //c
    'r', 0x00, //r
    'o', 0x00, //o
    'p', 0x00, //p
    'h', 0x00, //h
    'o', 0x00, //o
    'n', 0x00, //n
    'e', 0x00, //e
};

void get_iserialnumber_str(u8 *ptr)
```



备注：修改之后，连电脑后，需要把声卡驱动卸载，再重装，描述符显示才会更改过来



**取消 PC 电脑音量调节**

这个不能全部为0，需要选择其他的bit(可以改为1)

![img140](/pic/140.png)

![img141](/pic/141.png)



**USB描述符序号**

USB描述符序号功能开启的话，对着电脑同一个USB口插，插第一个机子，显示还是2.0 ，但插第二台，就变成2.0-1 依次类推。

若不想要这个功能，可以按以下截图关闭：

![img142](/pic/142.png)



**UAC设备OT端描述修改：**

![img143](/pic/143.png)

我们默认配置的是扬声器描述，如果需要修改为头戴式耳机等描述，按照下图修改，

![img144](/pic/144.png)

**USB描述符解析：**

**1、描述符类型**

![img145](/pic/145.png)

**2、各类描述符介绍**

标准的USB设备有5种USB描述符：设备描述符，配置描述符，字符串描述符，接口描述符，端点描述符。

下面详解： 

**（1）设备描述符：**

一个设备只有一个设备描述符

```
typedef struct _USB_DEVICE_DESCRIPTOR_
{
//描述符长度：固定为0x12，18个字节
    0x12,       //bLength
//描述符类型:设备描述符为0x01
    0x01,        //bDescriptorType,描述符
//USB版本号：0x200:USB2.0版本  0x110:USB1.1版本
    0x00, 0x02,     // bcdUSB: USB 2.0小端格式
//设备类型：详情见此链接：https://www.usb.org/defined-class-codes
    0x00,        //bDeviceClass 由接口描述符定义
//设备子类：进一步定义bDeviceClass的USB设备类,子类型代码
//（由USB分配）．如果bDeviceClass值是0，一定要设置为0．
//其它情况就跟据USB-IF组织定义的编码．
    0x00,        //bDeviceSubClass,
//协议代码（由USB分配）．如果使用USB-IF组织定义的协议，
//就需要设置这里的值，否则直接设置为0。如果厂商自己定义的可以设置为FFH．
    0x00,        //bDeviceProtol,
//端点0最大数据包大小（只有8,16,32,64有效）
    0x40；        //bMaxPacketSize0,64字节
//PID,供应商ID（由USB分配）
    'J', 'L',     // idVendor: 0x4a4c - JL
//VID
    'U', 'A',     // idProduct: chip id
//设备出产编码．由厂家自行设置．
    0x00, 0x01,     // bcdDevice: version 1.0
//厂商字符串描述符索引值
    0x01,       // iManufacturer: Index to string descriptor that contains the string <Your Name> in Unicode
//产品字符串描述符索引值
    0x02,       // iProduct: Index to string descriptor that contains the string <Your Product Name> in Unicode
//设备序列号字符串描述索引值    
    0x03,       // iSerialNumber: none
//USB设备所支持的配置数量
    0x01        // bNumConfigurations: 1

}USB_DEVICE_DESCRIPTOR;
```

![img146](/pic/146.png)

 **（2）配置描述符**

配置描述符：配置描述符定义了设备的配置信息，一个设备可以有多个配置描述符

```
static const u8 sConfigDescriptor[] = {    //<Config Descriptor
//ConfiguraTIon
//bLength : 描述符大小．固定为0x09．
    0x09,    //bLength
//配置描述符类型．固定为0x02．
    0x02,    //DescriptorType : ConfigDescriptor
//返回整个数据的长度．指此配置返回的配置描述符，接口描述符以及端点描述符的全部大小
    0, 0, //TotalLength
// 配置所支持的接口数．指该配置配备的接口数量，也表示该配置下接口描述符数量
    0,//bNumInterfaces: 在set_descriptor函数里面计算
//作为Set Configuration的一个参数选择配置值
    0x01,    //bConfiguration Value - ID of this configuration
//用于描述该配置字符串描述符的索引
    0x00,    //Unused
// 供电模式选择．Bit4-0保留，D7:总线供电，D6:自供电，D5:远程唤醒
#if USB_ROOT2
    0xA0,    //Attributes:Bus Power remotewakeup
#else
    0x80,    //Attributes:Bus Power
#endif
//最大电流
    50,     //MaxPower * 2ma
};
```

 **（3）字符串描述符**

字符串描述符是可选的．如果不支持字符串描述符，其设备，配置，接口描述符内的所有字符串描述符索引都必须为０,这个的描述比较简单，不做其他讲解

```
static const u8 MANUFACTURE_STR[] = {
    34,         //该描述符的长度为34字节
    0x03,       //字符串描述符的类型编码为0x03
// Unicode编码字符串
    0x4a, 0x00, //J
    0x69, 0x00, //i
    0x65, 0x00, //e
    0x6c, 0x00, //l
    0x69, 0x00, //i
    0x20, 0x00, //
    0x54, 0x00, //T
    0x65, 0x00, //e
    0x63, 0x00, //c
    0x68, 0x00, //h
    0x6e, 0x00, //n
    0x6f, 0x00, //o
    0x6c, 0x00, //l
    0x6f, 0x00, //o
    0x67, 0x00, //g
    0x79, 0x00, //y
};
```

**（4）接口描述符**

接口描述符：接口描述符说明了接口所提供的配置，一个配置所拥有的接口数量通过配置描述符的bNumInterfaces决定

```
//此处以USB游戏操作杆举例
typedef struct _USB_INTERFACE_DESCRIPTOR{
//描述符大小．固定为0x09
    0x09,      //bLength,
//接口描述符类型．固定为0x04
    0x04,      //bDescriptorType,
//该接口的编号,接口数量有设备描述符的bNumInterfaces字段决定
    0x00,      //bInterfaceNumber,
//备用接口编号
    0x00,      //bAlternateSetting,
//使用端点数量,端点０除外
    0x01,      //bNumEndpoint,
//接口类型代码，与设备描述符的bdeviceclass对应
    0x03,      //bInterfaceClass,HID(人机接口设备）
//接口子类类型代码，与设备描述符的bdevicesubclass对应
    0x01,      //bInterfaceSubClass HID:0x00:无子类  0x01:启动接口 2-255保留
//接口协议，与设备描述符的bdeviceProtocol对应
    0x02,      //bInterfaceProtocol,HID:0x00:none   0x01:键盘  0x02：鼠标  3-255：保留
//字符串描述符的索引
    0x00      //iInterface

}USB_INTERFACE_DESCRIPTOR;
```

**（5）端点描述符**

端点描述符：USB设备中的每个端点都有自己的端点描述符，由接口描述符中的bNumEndpoint决定其数量

```
typedef struct _USB_ENDPOINT_DESCRIPTOR_
{
///Endpoint IN
//描述符大小．固定为0x07
    0x07，
//接口描述符类型．固定为0x05
    0x05,
//USB设备的端点地址．Bit7，方向，对于控制端点可以忽略，
//1/0:IN/OUT．Bit6-4，保留．BIt3-0：端点号
    0x80 | 1,
//端点属性．Bit7-2，保留．BIt1-0：00控制，01同步，02批量，03中断
    0x02,
//本端点接收或发送的最大信息包大小
    0x0040,//两个byte
    0x01,
///Endpoint OUT
    USB_DT_ENDPOINT_SIZE,
    USB_DT_ENDPOINT,
    MSD_BULK_EP_OUT,
    USB_ENDPOINT_XFER_BULK,
    LOBYTE(MAXP_SIZE_BULKOUT), HIBYTE(MAXP_SIZE_BULKOUT),
    0x01,

}USB_ENDPOINT_DESCRIPTOR;
```

**（6）HID描述符**

```
    //HIDDescriptor:
    0x09,                      // bLength
    //固定0x21，HID描述符
    0x21,            // bDescriptorType, HID Descriptor
    //hid版本 1.0
    0x00, 0x01,                // bcdHID, HID Class Specification release NO.
    //国家代码
    0x00,                      // bCuntryCode, Country localization (=none)
    //附加特定描述符数量，正常至少为1，要有报告描述符
    0x01,                       // bNumDescriptors, Number of descriptors to follow
    //附加描述符类型：0x21:HID  0x22:0x22  实体描述符：0x23
    0x22,                       // bDescriptorType, Report Desc. 0x22, Physical Desc. 0x23
    //附加特定描述符的字节长度
    0,//LOW(ReportLength)
    0, //HIGH(ReportLength)
```



### 4.2.3. USB音频参数修改

- 修改USB AUDIO的采样率

```
#define SPK_AUDIO_RATE 16000
```

- 修改USB MIC的采样率

```
#define MIC_AUDIO_RATE 16000
```

- 单声道改双声道

```
#define MIC_CHANNEL 2
```

- 修改SPK位深度

```
#define     SPK_AUDIO_RES               24

///Type 1 Format type descriptor
    0x0b,     //Length
    USB_DT_CS_INTERFACE,       //DescriptorType:audio interface descriptor
    UAC_FORMAT_TYPE,      //DescriptorSubType:Format_type
    UAC_FORMAT_TYPE_I,       //FormatType:Format type 1
    SPK_CHANNEL,       //NumberOfChannel
    0x03,       //SubframeSize:3byte               此处要修改
    SPK_AUDIO_RES,      //BitsResolution:24bit
```

![img147](/pic/147.png)

```
 //24转16bit--去掉低8bit      
    u8 *sbuf = (u8 *)ep_buffer;
    u32 i, j;
    j = 0;
    for (i = 0; i < rx_len; i++) {
        if ((i % 3) == 0) {
            continue;
        }
        sbuf[j] = sbuf[i];
        j++;
    }
    rx_len = rx_len * 2 / 3;
```

- 修改SPK采样率96K

```
#ifndef SPK_AUDIO_RATE
#define SPK_AUDIO_RATE              96000//48000
#endif

#if TCFG_USB_SLAVE_AUDIO_ENABLE
#define     AUDIO_DMA_SIZE  576+192    //增大buf
#else
#define     AUDIO_DMA_SIZE  0
#endif
```



### 4.2.4. USB音频流位置

![img148](/pic/148.png)

![img149](/pic/149.png)



### 4.2.5. SDK PC事件处理函数

```
/*----------------------------------------------------------------------------*/
/**@brief    pc事件处理
@param    event: 事件
@param    value: 参数
@return   0：成功
@note
*/
/*----------------------------------------------------------------------------*/
static int usb_device_event_handler(u8 event, int value)
```



### 4.2.6. PC模式，电脑上取消平衡选项

![img150](/pic/150.png)

修改如下：

![img151](/pic/151.png)



### 4.2.7. 停止和启动PC检测的接口

```
extern void usb_detect_timer_del();//停止检测
extern void usb_detect_timer_add();//启动检测
```



### 4.2.8. 第一次默认音量设置

![img152](/pic/152.png)



## 4.3. FAQ

**1、USB线过长导致插某些电脑无法识别处理**

1、开启USB口强驱功能：

![img153](/pic/153.png)

2、VDDIO 提高到3.6V档位



**2、PID/VID/SN机器相同会导致电脑重启**

可能电脑里面的驱动程序没有完全卸载 （参考以下操作进行）

[Win7系统如何卸载残留无用驱动设备_卸载隐藏的无用驱动](https://blog.csdn.net/pan0755/article/details/53708336)



**3、AC696X 卡和U盘复用时卡不在线时插PC要能识别修改**

当卡和U盘复用时，默认SDK是配置关闭PC模式的。如果强制开启来的话，插PC是无法检测到PC模式的。但通过按键切模式，可以切到PC模式。如果想要做到插PC能自动识别，需要对照以下task_pc.c文件修改 （注意：仅支持卡不在线时，插PC识别）



【金山文档】 AC696X 卡和U盘复用时卡不在线时插PC要能识别修改

[AC696X 卡和U盘复用时卡不在线时插PC要能识别修改](https://www.kdocs.cn/view/l/cjPzT5jTOcoy?openfrom=docs)



**4、不同设备接到电脑上要让电脑认为是同一个设备修改点**

此处改为1

![img154](/pic/154.png)