# 6. GPIO

## 6.1. GPIO的工作模式

**a. 输入模式（模拟，上拉，下拉，浮空）**

在输入模式时，输出被禁止。

可通过输入数据寄存器DIR 读取 I/O 状态。

输入模式可以配置为模拟、上拉、下拉以及浮空模式。上拉和下拉输入很好理解，默认的电平由上拉或者下拉决定。

浮空输入的电平是不确定的，完全由外部的输入决定。

模拟输入则用于 ADC 采集。

**b. 输出模式（）**

**状态说明**

- 方向：有输入，有输出，无开漏。
- 上下拉：所有IO都有上下拉, 电阻固定, 但不同芯片, 或不同引脚的阻值是有差异的, 具体看芯片的规格书。输入状态才有上下拉。
- 水平：输出高(电压接近于VDDIO电压)，输出低(相当于地，灌电流形式)
- 能力：普通输出、强输出、超强输出，3种输出能力。超强输出只有极少IO有此能力。
- 状态：数字态，模拟态，2种状态。输入状态下AD检测才用模拟态。
- 读取：输入数字态，可以读取IO的电压高低。 **IO的承受电压不能高于VDDIO,否则会有倒灌,从而影响其他IO的检测**



## 6.2. 接口说明

第一个参数都是IO的宏定义, 如：IO_PORTA_00，指 PA0

- gpio_set_direction() 设置IO的方向，第二个参数：1输入，0输出
- gpio_set_pull_up() 设置上拉电阻的使能，第二个参数：1开启，0关闭
- gpio_set_pull_down() 设置下拉电阻的使能，第二个参数：1开启，0关闭
- gpio_set_output_value() 设置输出电压水平，第二个参数：1高，0低
- gpio_set_die(), gpio_set_dieh() 设置IO的状态，第二个参数：1数字态，0模拟态
- gpio_set_hd0(), gpio_set_hd() 设置IO的能力，第二个参数：1强输出，0普通输出
- gpio_read() 输入数字态下读取电压水平，返回值：1是高，0是低



## 6.3. 特殊IO

- usb_iomode(),usb1_iomode()  参数1：普通IO，0：是USB口

**寄存器说明**

```
typedef struct {
    __RW __u32 OUT;   //gpio_set_output_value
    __RO __u32 IN;    //gpio_read
    __RW __u32 DIR;   //gpio_set_direction
    __RW __u32 DIE;   //gpio_set_die
    __RW __u32 PU;    //gpio_set_pull_up
    __RW __u32 PD;    //gpio_set_pull_down
    __RW __u32 HD0;   //gpio_set_hd0
    __RW __u32 HD;    //gpio_set_hd
    __RW __u32 DIEH;  //gpio_set_dieh
} JL_PORT_FLASH_TypeDef;
```



## 6.4. GPIO设置范例

**设置输出高低**

```
u32 gpio = IO_PORTA_00;//指定IO
gpio_set_pull_down(gpio, 0);
gpio_set_pull_up(gpio, 0);
gpio_set_die(gpio, 1);
gpio_set_hd(gpio, 0);//看需求是否需要开启强推,会导致芯片功耗大
gpio_set_hd0(gpio, 0);
gpio_set_direction(gpio, 0);
gpio_set_output_value(gpio, 1); //1高0低
```

**设置输入读取IO高低**

```
u32 gpio = IO_PORTA_00;//指定IO
gpio_set_pull_down(gpio, 0);//看需求是否需要开内部下拉
gpio_set_pull_up(gpio, 0);//看需求是否需要开内部上拉
gpio_set_die(gpio, 1);
gpio_set_direction(gpio, 1);
delay(100);//设置方向寄存器后,不能立马读电压
int level = gpio_read(gpio);
```

**设置输入模拟检测电压**

```
u32 gpio = IO_PORTA_00;//指定IO
gpio_set_pull_down(gpio, 0);//看需求是否需要开内部下拉
gpio_set_pull_up(gpio, 0);//看需求是否需要开内部上拉
gpio_set_die(gpio, 0);
gpio_set_direction(gpio, 1);
```

**打印监控IO状态**

```
JL_PORT_FLASH_TypeDef *PORT = JL_PORTA; //指定组口
u8 bit = 0; //指定位口，组合起来，即 PA0 == IO_PORTA_00
printf("port:DIR-%d,PU-%d,PD-%d,DIE-%d,DIEH-%d,HD0-%d,HD-%d,OUT-%d,IN-%d\n",
    (PORT->DIR &BIT(bit))?1:0,
    (PORT->PU  &BIT(bit))?1:0,
    (PORT->PD  &BIT(bit))?1:0,
    (PORT->DIE &BIT(bit))?1:0,
    (PORT->DIEH&BIT(bit))?1:0,
    (PORT->HD0 &BIT(bit))?1:0,
    (PORT->HD  &BIT(bit))?1:0,
    (PORT->OUT &BIT(bit))?1:0,
    (PORT->IN  &BIT(bit))?1:0
 );
```



## 6.5. GPIO的输出电平

GPIO的电平由VDDIO供电，假如需要某个IO输出3.0v，则需要将VDDIO的电平设为3.0v

