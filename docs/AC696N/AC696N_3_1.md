# 1. 蓝牙相关应用

## 1.1. 获取歌曲信息

1. 把以下变量置1

```
const u8 more_avctp_cmd_support = 1;
//检查以下宏是否定义
#define TCFG_DEC_ID3_V1_ENABLE                ENABLE
#define TCFG_DEC_ID3_V2_ENABLE                ENABLE
```

1. void bredr_handle_register() 添加获取歌曲信息的回调

```
////获取歌曲信息回调
bt_music_info_handle_register(user_get_bt_music_info);
```

1. 添加歌曲信息的处理函数(如果SDK已实现该函数，使用默认就可以)

```
/*----------------------------------------------------------------------------*/
/**@brief    蓝牙歌词信息获取回调
   @param
   @return
   @note
   const u8 more_avctp_cmd_support = 1;置上1
   需要在void bredr_handle_register()注册回调函数
   要动态获取播放时间的，可以发送USER_CTRL_AVCTP_OPID_GET_PLAY_TIME命令就可以了
   要半秒或者1秒获取就做个定时发这个命令
*/
/*----------------------------------------------------------------------------*/
void user_get_bt_music_info(u8 type, u32 time, u8 *info, u16 len)
{
    //profile define type: 1-title 2-artist name 3-album names 4-track number 5-total number of tracks 6-genre  7-playing time
    //JL define 0x10-total time , 0x11 current play position
    u8  min, sec;
    printf("type %d\n", type );
    if ((info != NULL) && (len != 0)) {
        printf(" %s \n", info);
    }
    if (time != 0) {
        min = time / 1000 / 60;
        sec = time / 1000 - (min * 60);
        printf(" time %d %d\n ", min, sec);
    }
}
```



## 1.2. 蓝牙空闲状态时间设置（可优化连接速度）

- 减少空间状态时间，可以减少蓝牙连接，TWS配对，无线测试盒连接的时间。但是相对功耗会高

```
//普通SDKe
set_idle_period_slot(1600);
```

SDK 默认值为 1600(时间实际为 1600*0.625ms)， 建议修改为 200。 该值最小为 100， 注意不能使用低功耗适用于音箱对功耗要求不高的产品使用。

![img104](/pic/104.png)



## 1.3. 蓝牙名修改

- 普通模式下蓝牙名（默认使用配置文件的蓝牙名）

```
const char *bt_get_local_name()
{
    return (const char *)(bt_cfg.edr_name);
}
```

- 独立自拍模式下的蓝牙名设置（该函数需要自行写入代码）

```
const char *bt_get_hid_name()
{
    return "JL_HID_DEFAULT";
}
```

- **注意：如果打开了TWS功能，需要修改HID名字需要修改以下内容**

需要自行添加判断

![img105](/pic/105.png)



- 动态修改蓝牙名

```
extern void hci_vendor_update_name(void);
int bt_modify_name(u8 *new_name)
{
    u8 new_len = strlen(new_name);

    if (new_len >= LOCAL_NAME_LEN) {
        new_name[LOCAL_NAME_LEN - 1] = 0;
    }

    if (strcmp(new_name, bt_cfg.edr_name)) {
        syscfg_write(CFG_BT_NAME, new_name, LOCAL_NAME_LEN);
        memcpy(bt_cfg.edr_name, new_name, LOCAL_NAME_LEN);
        hci_vendor_update_name();
        log_info("mdy_name sucess\\n");
        return 1;
    }
    return 0;
}
```

- BLE名字修改 搜索程序上 HCI_EIR_DATATYPE_COMPLETE_LOCAL_NAME字样，找到数据部分的传参就是实际的蓝牙名。根据实际需要修改指针指向的内容。**注意：包数据最长只有31字节**每个包都是 31 字节，数据包中分为有效数据（significant）和无效数据（non-significant）两部分。 有效数据部分 包含若干个广播数据单元，组成是： 长度 Len ，表示这个 AD Structure 的长度（除去 len本身 1） 类型 AD Type 标记这段广播数据代表什么， 比如设备名， uuid 等。 数据 AD data 无效数据部分 广播包的长度必须是 31 个 byte，如果有效数据部分不到 31 自己，剩下的就用 0 补全。这部分的数据是无效的。 蓝牙名 数据类型 `HCI_EIR_DATATYPE_COMPLETE_LOCAL_NAME`



## 1.4. A2DP延时

- 音箱版本SDK

```
const int CONFIG_A2DP_DELAY_TIME            = 200;
```



## 1.5. A2DP开关

```
/*----------------------------------------------------------------------------*/
/**@brief  蓝牙  开关a2dp
   @param
   @return
   @note
*/
/*----------------------------------------------------------------------------*/
void bredr_a2dp_open_and_close()
{
    if (get_curr_channel_state() & A2DP_CH) {
        puts("start to disconnect a2dp ");
        user_send_cmd_prepare(USER_CTRL_DISCONN_A2DP, 0, NULL);
    } else {
        puts("start to connect a2dp ");
        user_send_cmd_prepare(USER_CTRL_CONN_A2DP, 0, NULL);
    }
}
```



## 1.6. AAC、SBC格式

**1. 开启AAC格式支持**

打开下面的宏定义

```
#define TCFG_BT_SUPPORT_AAC                 1   //AAC格式支持
```

- AC696音箱版本SDK还需要打开(1.5.0SDK及以上才支持AAC)

SDK\apps\soundbox\log_config\lib_media_config.c

```
const int config_aac_dec_use_malloc     = 1;
```

**2. SBC、AAC码率**

1. SBC码率修改接口：

![img106](/pic/106.png)

SBC是一种 可设置Bitpool的编解码，Bitpool设置范围在2~53之间，但在通用的A2DP协议(不考虑V1.2的Extension)中，对于联合立体声，Bitpool可用范围在35~53之间，因此可用码率在229kbps~345kbps之间，但要注意，这并不是可变码率。具体的Bitpool数值和码率的运算可以使用如下网站的工具：

[Bluetooth A2DP SBC Bitrate Calculator](https://btcodecs.valdikss.org.ru/sbc-bitrate-calculator/)

![img107](/pic/107.png)

**扩展：**

1、sbc是通用的最基本的解码方式，蓝牙耳机都支持，支持44khz/16bit的音频，最高码率是328kbps，延时大约220ms，所以音质一般。

2、aac是苹果产品通用的解码方式，跟sbc差不多，支持44khz/16bit的音频，最高码率512kbps，延时大约100ms，音质略好于sbc。

3、aptx是高通的专利，支持48khz/16bit的音频，最高码率352kbps，延时约40ms，音质好于sbc，但相比sbc提升并不大。

4、ldac是真正的高音质解码，索尼出品，支持96khz/24bit的音频，最高码率达990kbps，接近无损解码。

5、lhac（hwa）也是接近无损解码，华为主推，支持96khz/24bit的音频，最高码率900kbps，可以媲美ldac

以flac格式的无损音乐为例，FLAC 24bit/96kHz典型压缩编码码率在2350kbps左右，我们网上下载的flac无损音质一般是44khz/16bit的，码率大约990kbps，网上下载的wav无损音乐一般也是44khz/16bit的，码率大约1400kbps。所以高品质的无损音乐体积是比较大的



## 1.7. HID独立模式

pps\soundbox\task_manager\bt\bt.c 添加对应消息

```
case KEY_CHANGE_MODE:
        if(__this->hid_mode){
            __this->hid_mode = 0;
            extern int app_task_switch_check(u8 app_task);
            if(app_task_switch_check(APP_MUSIC_TASK)||\
            app_task_switch_check(APP_LINEIN_TASK)\
            ){
                ret = false;
            }else{
                user_change_profile_mode(__this->hid_mode);///HID设备名称， 默认蓝牙名称追加_HID
            }
        }else{
            __this->hid_mode = 1;
            user_change_profile_mode(__this->hid_mode);///HID设备名称， 默认蓝牙名称追加_HID
            //如果要修改名称， 可以重写重写这个函数,上面有重写例子
            //const char *__attribute__((weak)) bt_get_hid_name()
        }
        break;
```



## 1.8. 音量同步

**1. 连接使用默认音量**

| AC芯片型号 | SDK                            | 修改方法                                                     | 补丁文件     |
| ---------- | ------------------------------ | ------------------------------------------------------------ | ------------ |
| AC696N     | ac696n_soundbox_sdk_v1.5.0以上 | 1. 配合外面重新定义一个变量                                                                                                              `u8 need_default_volume = 127*8/10; 为初始化80%。` | 无需替换文件 |

**2. 首次连接使用默认音量**

- ac696n_soundbox_sdk_v1.7.0

【金山文档】 SDK170 修改首次连接音量同步值，之后按记忆

 [btstack-696-v170-音量支持首次连接固定音量-20251009](https://www.kdocs.cn/view/l/ct9KrZFTyLXL?openfrom=docs)

**3. 自定义音量同步下，手机每一个对应的音量大小**

![img108](/pic/108.png)

上图是单独调节模拟音量的，如果需要更加细致的音量调节，需要调节数字音量，找到app_audio控制音量处修改：

```
static unsigned short user_combined_vol_list[31][2] = {
    { 0,     0}, //0: None
    {30,    65}, // 1:-48.00 db
    {30,    92}, // 2:-45.00 db
    {30,   130}, // 3:-42.00 db
    {30,   184}, // 4:-39.00 db
    {30,   260}, // 5:-36.00 db
    {30,   367}, // 6:-33.00 db
    {30,   518}, // 7:-30.00 db
    {30,   732}, // 8:-27.00 db
    {30,  1034}, // 9:-24.00 db
    {30,  1460}, // 10:-21.00 db
    {30,  2063}, // 11:-18.00 db
    {30,  2914}, // 12:-15.00 db
    {30,  4115}, // 13:-12.00 db
    {30,  5813}, // 14:-9.00 db
    {30,  8211}, // 15:-6.00 db
    {30,  9213}, // 16:-5.00 db
    {30,  9600}, // 17:-4.64 db
    {30, 10003}, // 18:-4.29 db
    {30, 10423}, // 19:-3.93 db
    {30, 10860}, // 20:-3.57 db
    {30, 11316}, // 21:-3.21 db
    {30, 11791}, // 22:-2.86 db
    {30, 12286}, // 23:-2.50 db
    {30, 12802}, // 24:-2.14 db
    {30, 13339}, // 25:-1.79 db
    {30, 13899}, // 26:-1.43 db
    {30, 14483}, // 27:-1.07 db
    {30, 15091}, // 28:-0.71 db
    {30, 15724}, // 29:-0.36 db
    {30, 16384}, // 30:0.00 db
};
static int audio_vol_set(u8 gain_l, u8 gain_r, u8 gain_rl, u8 gain_rr, u8 fade)
{
#if (AUDIO_VOL_MANUAL)
    return 0;
#endif

#if (AUDIO_OUTPUT_WAY == AUDIO_OUTPUT_WAY_FM)
    return 0;
#endif

#if (AUDIO_OUTPUT_WAY == AUDIO_OUTPUT_WAY_IIS)
    extern void *iis_digvol_last;
    if (iis_digvol_last) {
        audio_dig_vol_set(iis_digvol_last, AUDIO_DIG_VOL_ALL_CH, gain_l);
    }
#endif

#if (TCFG_APP_FM_EMITTER_EN)
    extern void *fmtx_digvol_last;
    audio_dig_vol_set(fmtx_digvol_last, AUDIO_DIG_VOL_ALL_CH, gain_l);
#endif

#if (AUDIO_OUTPUT_WAY == AUDIO_OUTPUT_WAY_BT)
    bt_emitter_set_vol(gain_l);
#endif
    /* r_printf("dac_fade_begin:0x%x\n", __this->fade_timer); */
    local_irq_disable();
    __this->fade_gain_l = gain_l;
    __this->fade_gain_r = gain_r;
    __this->fade_gain_rl = gain_rl;
    __this->fade_gain_rr = gain_rr;

#if AUDIO_OUTPUT_INCLUDE_DAC

#if (TCFG_AUDIO_DAC_CONNECT_MODE == DAC_OUTPUT_MONO_L)
    audio_dac_vol_set(TYPE_DAC_AGAIN, BIT(0), gain_l, fade);
    audio_dac_vol_set(TYPE_DAC_DGAIN, BIT(0), gain_l ? DEFAULT_DIGTAL_VOLUME : 0, fade);
#elif (TCFG_AUDIO_DAC_CONNECT_MODE == DAC_OUTPUT_MONO_R)
    audio_dac_vol_set(TYPE_DAC_AGAIN, BIT(1), gain_r, fade);
    audio_dac_vol_set(TYPE_DAC_DGAIN, BIT(0), gain_r ? DEFAULT_DIGTAL_VOLUME : 0, fade);
#else
    //将原先此处固定数字音量然后设置模拟音量的方式 改为 同时更改数字和模拟音量，注意TCFG_AUDIO_DAC_CONNECT_MODE的定义
    u16 analog_vol_l  = user_combined_vol_list[gain_l][0];
    u16 analog_vol_r  = user_combined_vol_list[gain_r][0];
    u16 digital_vol_l = user_combined_vol_list[gain_l][1];
    u16 digital_vol_r = user_combined_vol_list[gain_r][1];

    audio_dac_vol_set(TYPE_DAC_AGAIN, BIT(0), analog_vol_l, fade);
    audio_dac_vol_set(TYPE_DAC_AGAIN, BIT(1), analog_vol_r, fade);
    audio_dac_vol_set(TYPE_DAC_DGAIN, BIT(0), digital_vol_l, fade);
    audio_dac_vol_set(TYPE_DAC_DGAIN, BIT(1), digital_vol_r, fade);
#endif

#if ((TCFG_AUDIO_DAC_CONNECT_MODE == DAC_OUTPUT_FRONT_LR_REAR_LR) \
    || (TCFG_AUDIO_DAC_CONNECT_MODE == DAC_OUTPUT_DUAL_LR_DIFF))
    audio_dac_vol_set(TYPE_DAC_AGAIN, BIT(2), gain_rl, fade);
    audio_dac_vol_set(TYPE_DAC_AGAIN, BIT(3), gain_rr, fade);
    audio_dac_vol_set(TYPE_DAC_DGAIN, BIT(2), gain_rl ? DEFAULT_DIGTAL_VOLUME : 0, fade);
    audio_dac_vol_set(TYPE_DAC_DGAIN, BIT(3), gain_rr ? DEFAULT_DIGTAL_VOLUME : 0, fade);
#endif

#endif // AUDIO_OUTPUT_INCLUDE_DAC

    local_irq_enable();

    return 0;
}
```

**4. 固定通话音量**

![img109](/pic/109.png)

**5. 首次连接同步通话音量**

![img110](/pic/110.png)

![img111](/pic/111.png)

![img112](/pic/112.png)

**6. 同步样机音量到手机端**

![img113](/pic/113.png)



## 1.9. 获取电话本功能

**使用指令**

```
user_send_cmd_prepare(USER_CTRL_PBAP_READ_ALL,0,NULL);
```

**回调函数**

```
//此处拿数据，结束标志：type == 255
void phonebook_packet_handler(u8 type, const u8 *name, const u8 *number, const u8 *date)
{
    static u16 number_cnt = 0;
    printf("NO.%d:", number_cnt);
    number_cnt++;
    printf("type:%d ", type);
    if (type == 0xff) {
        number_cnt = 0;
    }
    if (name) {
        printf(" NAME:%s  ", name);
    }
    if (number) {
        printf("number:%s  ", number);
    }
    if (date) {
        printf("date:%s ", date);
    }
    putchar('\n');
}
```

**补丁**

1、AC696X  SDK170 需要替换以下库文件：（2023年11月14日 更新：修复停止后无法再读问题）

[btstack_br25_170_231114(修复获取电话本问题)](https://www.kdocs.cn/view/l/cquUrup3SUEb?openfrom=docs)

2、 在函数 void bt_function_select_init()中， 用**change_hci_class_type(0x200420);**或者**change_hci_class_type(0x240420);**重新设置一下设备的类型编码

3、在 apps\config\bt_profile_config.c 中加上 PBAP 的协议定义。 

![img114](/pic/114.png)

![img115](/pic/115.png)

```
#if (USER_SUPPORT_PROFILE_PBAP==1)
extern const u8 sdp_pbap_service_data[];
u8 pbap_profile_support = 1;
SDP_RECORD_HANDLER_REGISTER(pbap_sdp_record_item) = {
    .service_record = (u8 *)sdp_pbap_service_data,
    .service_record_handle = 0x00010007,
};
#endif
```



## 1.10. 蓝牙功率

接口函数

```
/* --------------------------------------------------------------------------*/
/**
 * @brief ble_set_fix_pwr
 *
 * @param fix (0~max)
 * 动态调整BLE的发射功率
 */
/* ----------------------------------------------------------------------------*/
void ble_set_fix_pwr(u8 fix);
/* --------------------------------------------------------------------------*/
/**
 * @brief bredr_set_fix_pwr
 *
 * @param fix (0~max)
 * 动态调整EDR的发射功率
 */
/* ----------------------------------------------------------------------------*/
void bredr_set_fix_pwr(u8 fix);

//pwr：普通状态pg_pwr：发起连接请求 iq_pwr：发现周围蓝牙设备 ble_pwr：BLE
void bt_max_pwr_set(u8 pwr, u8 pg_pwr, u8 iq_pwr, u8 ble_pwr);
```



## 1.11. 蓝牙rssi信号强度获取

**BREDR 获取已连接设备的rssi**

![img116](/pic/116.png)



**BLE 获取已连接设备的rssi**

![img117](/pic/117.png)



## 1.12. 清除连接记录

**1、 在蓝牙模式下非连接状态下执行：**

​       清除手机配对信息： user_send_cmd_prepare(USER_CTRL_DEL_ALL_REMOTE_INFO, 0, NULL);

​       清除 TWS 配对信息： bt_tws_remove_pairs();

**2、如果是手机和 TWS 连接的状态：**

​      先断开手机连接： user_send_cmd_prepare(USER_CTRL_DISCONNECTION_HCI, 0, NULL);

​      断开后清除手机配对信息：

​     case BT_STATUS_FIRST_DISCONNECT:

​     case BT_STATUS_SECOND_DISCONNECT:

​     user_send_cmd_prepare(USER_CTRL_DEL_ALL_REMOTE_INFO, 0, NULL);

​     清除 TWS 配对信息： tws_api_remove_pairs();

**3、非蓝牙模式下：**

清除 TWS 配对信息： 

![img118](/pic/118.png)

清除手机配对信息：先记录要清除配对信息的标志，进入蓝牙模式后再调用

user_send_cmd_prepare(USER_CTRL_DEL_ALL_REMOTE_INFO, 0, NULL);

来清除手机配对信息。

![img119](/pic/119.png)

例如在idle模式下清除配对信息：

![img120](/pic/120.png)

进入蓝牙模式后执行清除：

![img121](/pic/121.png)



## 1.13. BT HID

1、HID描述符，如需修改参考官方标准HID协议文档

```
const u8 use_hid_descriptor[] = {
    0x05, 0x01,        // Usage Page (Generic Desktop Ctrls)
    0x09, 0x06,        // Usage (Keyboard)
    0xA1, 0x01,        // Collection (Application)
    0x05, 0x07,        //   Usage Page (Kbrd/Keypad)
    0x85, 0x01,        //   Report ID (1)
    0x19, 0xE0,        //   Usage Minimum (0xE0)
    0x29, 0xE7,        //   Usage Maximum (0xE7)
    0x15, 0x00,        //   Logical Minimum (0)
    0x25, 0x01,        //   Logical Maximum (1)
    0x75, 0x01,        //   Report Size (1)
    0x95, 0x08,        //   Report Count (8)
    0x81, 0x02,        //   Input (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
    0x95, 0x01,        //   Report Count (1)
    0x75, 0x08,        //   Report Size (8)
    0x81, 0x03,        //   Input (Const,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)
    0x95, 0x05,        //   Report Count (5)
    0x75, 0x01,        //   Report Size (1)
    0x05, 0x08,        //   Usage Page (LEDs)
    0x19, 0x01,        //   Usage Minimum (Num Lock)
    0x29, 0x05,        //   Usage Maximum (Kana)
    0x91, 0x02,        //   Output (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position,Non-volatile)
    0x95, 0x01,        //   Report Count (1)
    0x75, 0x03,        //   Report Size (3)
    0x91, 0x03,        //   Output (Const,Var,Abs,No Wrap,Linear,Preferred State,No Null Position,Non-volatile)
    0x95, 0x06,        //   Report Count (6)
    0x75, 0x08,        //   Report Size (8)
    0x15, 0x00,        //   Logical Minimum (0)
    0x26, 0xA4, 0x00,  //   Logical Maximum (164)
    0x05, 0x07,        //   Usage Page (Kbrd/Keypad)
    0x19, 0x28,        //   Usage Minimum (0x28)
    0x2A, 0x28, 0x00,  //   Usage Maximum (0x28)
    0x81, 0x00,        //   Input (Data,Array,Abs,No Wrap,Linear,Preferred State,No Null Position)
    0xC0,              // End Collection

    0x05, 0x0C,        // Usage Page (Consumer)
    0x09, 0x01,        // Usage (Consumer Control)
    0xA1, 0x01,        // Collection (Application)
    0x85, 0x02,        //   Report ID (2)
    0x75, 0x10,        //   Report Size (16)
    0x95, 0x01,        //   Report Count (1)
    0x15, 0x01,        //   Logical Minimum (1)
    0x26, 0xFC, 0x03,  //   Logical Maximum (1020)
    0x19, 0x01,        //   Usage Minimum (Consumer Control)
    0x2A, 0xFC, 0x03,  //   Usage Maximum (0x03FC)
    0x81, 0x00,        //   Input (Data,Array,Abs,No Wrap,Linear,Preferred State,No Null Position)
    0xC0,              // End Collection
};
```

2、使用例子

```
struct user_hid_consumer_cmd {
    //Bluetooth HID Protocol Message Header Octet
    u8 HIDP_Hdr;
    //Bluetooth HID Boot Reports
    u8 report_id;
    u8 button;
} _GNU_PACKED_;

static struct user_hid_consumer_cmd u_consumer = {
    .HIDP_Hdr = 0xA1,
    .report_id = 0x02,
    .button = 0,
};
// consumer key
#define CONSUMER_MENU               0x01
#define CONSUMER_MENU_ESCAPE        0x02
#define CONSUMER_AC_HOME            0x04
void hid_consumer_send_test(u8 menu)
{
    y_printf("hid_consumer_send_test menu = %d", menu);
    if (menu == 1) {
        u_consumer.button = CONSUMER_MENU;
    }
    if (menu == 2) {
        u_consumer.button = CONSUMER_MENU_ESCAPE;
    }
    if (menu == 3) {
        u_consumer.button = CONSUMER_AC_HOME;
    }
    put_buf((u8 *)&u_consumer, sizeof(u_consumer));
    user_data_write_sub((u8 *)&u_consumer, sizeof(u_consumer));
    u_consumer.button = 0x00;
    user_data_write_sub((u8 *)&u_consumer, sizeof(u_consumer));
}

u8 sdp_make_hid_service_data[0x200];
static void user_hid_sdp_init(const u8 *hid_descriptor, u16 size)
{
    int real_size;
    real_size = sdp_create_diy_hid_service(sdp_make_hid_service_data, sizeof(sdp_make_hid_service_data), hid_descriptor, size);
    printf("dy_hid_service(%d):", real_size);
}
void user_hid_descriptor_init(void)
{
    __change_hci_class_type(BD_CLASS_KEYBOARD);  /*键盘图标，需要更换手机显示图标的可以自己改成以前的值*/
    user_hid_init(user_hid_interrupt_handler);
    user_hid_sdp_init(use_hid_descriptor, sizeof(use_hid_descriptor));
}

//用户修改成自定义的描述符说明
//1、在void bredr_handle_register();中调用user_hid_descriptor_init;
//2、user_hid_sdp_init换成自己的表
//3、文件上方HID_CHANGE_DESCRIPTOR定义为1
//4、在bt_profile_config.c文件中extern sdp_make_hid_service_data数组，
//  把sdp_hid_service_data替换为sdp_make_hid_service_data.
//5、把const u8 hid_conn_depend_on_dev_company的值置0;
```

```
#define USER_HID_MUSIC_PP           0x00CD      //播放暂停
#define USER_HID_MUSIC_NEXT         0x00B5      //下一首
#define USER_HID_MUSIC_PREV         0x00B6      //上一首
#define USER_HID_VOL_UP             0x00E9      //音量+
#define USER_HID_VOL_DOWN           0x00EA      //音量-
#define USER_HID_FAST_FORWARD       0x00B3      //快进
#define USER_HID_REWIND             0x00B4      //快退
#define USER_HID_IOS_HOME           0x0040      //IOS HOME键
```

```
switch (key_event) {
    case  KEY_HID_TEST_1:
        log_info("KEY_HID_TEST_1");
        edr_hid_key_deal_test(USER_HID_MUSIC_PP);
        break;
    case  KEY_HID_TEST_2:
        log_info("KEY_HID_TEST_2");
        edr_hid_key_deal_test(USER_HID_MUSIC_NEXT);
        break;
    case  KEY_HID_TEST_3:
        log_info("KEY_HID_TEST_3");
        edr_hid_key_deal_test(USER_HID_MUSIC_PREV);
        break;
    case  KEY_HID_TEST_4:
        log_info("KEY_HID_TEST_4");
        edr_hid_key_deal_test(USER_HID_VOL_UP);
        break;
    case  KEY_HID_TEST_5:
        log_info("KEY_HID_TEST_5");
        edr_hid_key_deal_test(USER_HID_VOL_DOWN);
        break;
    case  KEY_HID_TEST_6:
        log_info("KEY_HID_TEST_6");
        edr_hid_key_deal_test(USER_HID_FAST_FORWARD);
        break;
    case  KEY_HID_TEST_7:
        log_info("KEY_HID_TEST_7");
        edr_hid_key_deal_test(USER_HID_REWIND);
        break;
    case  KEY_HID_TEST_8:
        log_info("KEY_HID_TEST_8");
        // edr_hid_long_key_deal_test(USER_HID_IOS_HOME);
        break;
}
```



## 1.14. TWS主从机相关

**1、使能TWS**

![img122](/pic/122.png)

**2、TWS配对设置**

![img123](/pic/123.png)

**3、TWS固定主机**

下图可以根据自己的需要修改判断条件（这里demo是左做主机）

![img124](/pic/124.png)

关闭主从切换

![img125](/pic/125.png)

**4、加快交叉配对速度（未连接手机时）**

![img126](/pic/126.png)

```
if(bt_user_priv_var.auto_connection_counter || !(gtws.state & BT_TWS_POWER_ON)){
    connect_and_connectable_switch(0);
}
else{
    connect_and_connectable_switch(2);
}
```



## 1.15. PINCODE

![img127](/pic/127.png)

修改方法

- AC696 音箱SDK

```
//开启pincode功能
extern void __set_simple_pair_flag(u8 flag); 
//添加位置bt_function_select_init下一行或者在bt_function_select_init中的最后一行
bt_function_select_init();
bt_set_simple_pair_flag(0);
//修改pincode默认值
const char *bt_get_pin_code()
{
    return "0250";
}
```

**注意：**

**必须在协议栈配置bt_function_select_init接口中设置**

![img128](/pic/128.png)

![img129](/pic/129.png)



## 1.16. 开启DUT模式

```
extern void bredr_set_dut_enble(u8 en, u8 phone); //en:开启   phone：手机是否能链接
bredr_set_dut_enble(1, 0);
```



## 1.17. 回连 多个设备

如果需要支持上电回连多个设置需要把以下变量置

```
const u8 more_addr_reconnect_support = 1;  

//设置上电回连设备的数量最多9台设备（1~9）
__set_auto_conn_device_num(9);
```



## 1.18. MAP方式获取安卓手机时间到样机

[696x_v1.7.0版本获取安卓时间补丁](https://www.kdocs.cn/view/l/caELKOXff1Uj?openfrom=docs)



## 1.19. HFP通话协议

**1、设置要保留hfp做电量显示，但不要蓝牙通话**

对应接口：

![img130](/pic/130.png)

调用接口函数

![img131](/pic/131.png)

**2、通话时按键切换手机的输入输出方式为蓝牙或者手机**

```
user_send_cmd_prepare(USER_CTRL_SCO_LINK, 0, NULL);
```



## 1.20. 获取设备蓝牙名

1、把以下变量置1

```
const int CONFIG_LMP_NAME_REQ_ENABLE  =  1;
```

2、void bredr_handle_register() 添加获取信息的回调

```
read_remote_name_handle_register(user_remote_name_hdl);
```

3、自定义user_remote_name_hdl函数

```
static void user_remote_name_hdl(u8 status, u8 *addr, u8 *name)
{
    printf("%s\n",__func__);
    put_buf(addr ,6);
    printf("name = %s\n",name);
}
```

4、发命令获取设备蓝牙名

```
user_send_cmd_prepare(USER_CTRL_READ_REMOTE_NAME, 6, user_addr);
//user_addr为设备蓝牙MAC
```